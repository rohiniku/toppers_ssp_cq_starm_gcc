
		TOPPERS/SSPカーネル
		ターゲット依存部 ポーティングガイド

		対応バージョン: Release 1.1.1
		最終更新: 2012年2月20日

このドキュメントは，TOPPERS/SSPカーネルを，未サポートのターゲットシステ
ムにポーティングするために必要となるターゲット依存部の実装方法を説明す
るものである．

----------------------------------------------------------------------
     TOPPERS/SSP Kernel
         Smallest Set Profile Kernel
 
     Copyright (C) 2011 by Meika Sugimoto
 
 上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
 ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
 変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
     用できる形で再配布する場合には，再配布に伴うドキュメント（利用
     者マニュアルなど）に，上記の著作権表示，この利用条件および下記
     の無保証規定を掲載すること．
 (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
     用できない形で再配布する場合には，次のいずれかの条件を満たすこ
     と．
   (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
       作権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
       報告すること．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
     また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
     由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
     免責すること．
 
 本ソフトウェアは，無保証で提供されているものである．上記著作権者お
 よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
 に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
 アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
 の責任を負わない．
 
----------------------------------------------------------------------

○目次

１．共通事項
	1.1 ターゲット依存部の構成
	1.2 名前の衝突の防止
	1.3 多重インクルードの防止
	1.4 アセンブリ言語とのヘッダファイルの共用 
	1.5 インクルード記述の方法
	1.6 クリティカルセクションの出入処理の実現に関する制約
２．システム構築環境のターゲット依存部
	2.1 ターゲット略称とターゲット依存部のディレクトリ
	2.2 Makefileのターゲット依存部
	2.3 開発環境名とコマンド名の設定
	2.4 コンパイルオプションとオブジェクトファイルの設定
	2.5 リンク方法の設定
	2.6 依存関係の定義
	2.7 その他の設定
３．TOPPERS共通定義のターゲット依存部
	3.1 ターゲット識別マクロ
	3.2 整数型の最大値・最小値・ビット数
	3.3 サイズの指定された整数型，その最大値・最小値，整数定数を作るマクロ
	3.4 サイズの指定された浮動小数点型，その最大値・最小値のマクロ
	3.5 コンパイラの拡張機能のためのマクロ定義
	3.6 標準的な定義の上書き
	3.7 アサーションのための定義
４．システムインタフェースレイヤ（SIL）のターゲット依存部
	4.1 全割込みロック状態の管理
	4.2 微少時間待ち
	4.3 プロセッサのエンディアン
	4.4 メモリ空間アクセス関数
	4.5 I/O空間アクセス関数
５．カーネルAPIのターゲット依存部
	5.1 ターゲット定義でサポートする機能
	5.2 割込み優先度の範囲
	5.3 タイムティックの定義
	5.4 メモリ領域確保のための型定義
	5.5 メモリ領域確保のためのマクロ
	5.6 オーバランハンドラ機能拡張のための定義（オプション）
６．カーネル実装のターゲット依存部
	6.1 カーネル実装のターゲット依存部の共通事項
		6.1.1 カーネル実装のターゲット依存部の構成要素
		6.1.2 ターゲット依存部の関数の命名規則
	6.2 トレースログ機能への対応
	6.2 システム状態の管理
		6.2.1 全割込みロック状態の管理
		6.2.2 コンテキストの管理
		6.2.3 CPUロック状態の管理
	6.3 割込みに関連するシステム状態の管理
		6.3.1 割込み優先度マスクの管理
		6.3.2 割込み要求禁止フラグの管理
		6.3.3 割込み要求のクリア
		6.3.4 割込み要求のプローブ
		6.3.5 割込みハンドラの先頭処理と末尾処理
	6.4 タスクディスパッチャ
		6.4.1 タスクコンテキストブロックとタスク初期化コンテキストブロック
		6.4.2 ディスパッチャ本体
		6.4.3 タスクコンテキストからのディスパッチ
		6.4.4 ディスパッチャの動作開始
		6.4.5 現在のコンテキストを捨ててディスパッチ
		6.4.6 タスクの起動処理
	6.5 割込みハンドラ
		6.5.1 割込みハンドラの出入口処理
		6.5.2 割込みハンドラ毎の出入口処理の生成
		6.5.3 割込みハンドラの設定
		6.5.4 割込み要求ラインの属性の設定
		6.5.5 割込み管理機能の初期化処理の変更
		6.5.6 デフォルトの割込みハンドラ
		6.5.7 カーネル管理外の割込み
	6.6 CPU例外ハンドラとCPU例外発生時のシステム状態の参照
		6.6.1 CPU例外ハンドラの出入口処理
		6.6.2 CPU例外ハンドラの出入口処理の生成
		6.6.3 CPU例外ハンドラの設定
		6.6.4 CPU例外管理機能の初期化処理の変更
		6.6.5 デフォルトのCPU例外ハンドラ
		6.6.6 CPU例外発生時のシステム状態の参照
	6.7 カーネルの起動・終了とスタック領域など
	6.8 カーネル内部のチューニング
		6.8.1 ビットマップサーチ
		6.8.2 ビットフィールド
	6.9 カーネル実装に関するその他の定義
		6.9.1 非タスクコンテキスト用のスタック領域
		6.9.2 空ラベルの定義
	6.10 カーネル実装のターゲット依存部のためのリネーム記述
	6.12 タイマドライバ
		6.12.1 タイマドライバのファイル構成
		6.12.2 タイマの初期化・終了処理・割込み処理
		6.12.3 性能評価用システム時刻の参照のための機能
７．コンフィギュレータ設定ファイルのターゲット依存部
	7.1 設定ファイルとターゲット依存部の位置付け
	7.2 パス2のテンプレートファイルのターゲット依存部
		7.2.1 ターゲット非依存部をインクルードする前に定義すべき変数
		7.2.2 ターゲット非依存部で定義される変数
	7.3 パス3のテンプレートファイルのターゲット依存部
	7.4 cfg1_out.cのリンクに必要なスタブの定義ファイル
８．システムサービス等のターゲット依存部
	8.1 システムサービスのターゲット依存部
	8.2 シリアルインタフェースドライバのターゲット依存部
		8.2.1 変数，データ型，管理関数
		8.2.2 デバイスサービスルーチン
		8.2.3 コールバックルーチン
	8.3 カーネル起動メッセージの出力のターゲット依存定義
	8.4 サンプルプログラムとテストプログラムのターゲット依存定義
９．その他
	9.1 ドキュメント
	9.2 パッケージ記述ファイル
１０．リファレンス
	10.1 ターゲット依存部のファイル一覧


１．共通事項

1.1. ターゲット依存部の構成

ターゲット依存部は，targetディレクトリの下に，ターゲットハードウェアと
開発環境の組み合わせ毎に用意する．ただし，ターゲット依存部の再利用性を
考慮し，プロセッサ，チップ，開発環境のみに依存する部分を，プロセッサ依
存部，チップ依存部，開発環境依存部という形で切り分けてもよい．切り分け
方は，ターゲット依存部の実装に任されている．プロセッサ依存部，チップ依
存部，開発環境依存部は，archディレクトリの下に置く．

SSPカーネルのターゲット依存部は，システム構築環境（Makefile等）のターゲッ
ト依存部，TOPPERS共通定義（t_stddef.h）のターゲット依存部，システムイン
タフェースレイヤ（SIL，sil.h）のターゲット依存部，カーネルAPI（kernel.h）
のターゲット依存部，カーネル実装のターゲット依存部（コンフィギュレータ
設定ファイルのターゲット依存部を含む），システムサービスのターゲット依
存部，ターゲット依存部に関するドキュメント等で構成される．

1.2. 名前の衝突の防止

TOPPERSプロジェクトが提供するソフトウェアのために，TOPPERS_で始まるシン
ボルを予約している．ヘッダファイル中に記述され，アプリケーションから参
照できる内部シンボルは，TOPPERS_で始まる名前とする．

また，_kernel_で始まるシンボルは，カーネル内部の変数や関数のために予約
している．カーネル内部の変数や関数の名前で，リンク時にアプリケーション
の名前と衝突する可能性があるものは，リネーム記述にリストアップすること
で，コンパイル時に_kernel_で始まる名前に置き換えることとしている．

1.3. 多重インクルードの防止

すべてのヘッダファイルは，多重にインクルードされるのを防止するための条
件コンパイル記述を入れることとする．例えば，target_config.hであれば，ファ
イルの先頭に

#ifndef TOPPERS_TARGET_CONFIG_H
#define TOPPERS_TARGET_CONFIG_H

を，ファイルの末尾に

#endif /* TOPPERS_TARGET_CONFIG_H */

を記述する．

1.4. アセンブリ言語とのヘッダファイルの共用 

SSPカーネルのヘッダファイルの多くは，アセンブリ言語のソースファイルから
もインクルードできるようにするために，次のルールに従って記述するものと
する．

・TOPPERS_MACRO_ONLYがマクロ定義されている場合には，アセンブリ言語では
　解釈できない記述（マクロ定義以外の記述）を除くように記述する．

・符号無し整数型の定数値は，UINT_CやULONG_Cなどの整数定数を作るためのマ
　クロを用いて記述する．ただし，アセンブリ言語のソースファイルからもイ
　ンクルードできるファイル中であっても，C言語のみで用いる定数をこれらの
　マクロを使って記述する必要はない．

また，カーネル実装においては，次のルールに従うものとする．

・アセンブリ言語からも用いる定数の定義中に型キャストを用いる場合には，
　CASTマクロを用いて記述する．

アセンブリ言語からヘッダファイルをインクルードする際には，必要に応じて，
TOPPERS_MACRO_ONLY，UINC_C，ULONG_C，CASTをマクロ定義してから，インクルー
ドしなければならない．

1.5. インクルード記述の方法

開発環境で用意されている標準ヘッダファイルおよびincludeディレクトリ下の
標準ヘッダファイルは，「#include <...>」によりインクルードする．

その他のヘッダファイルは，「#include "..."」によりインクルードする．ヘッ
ダファイルが，カレントディレクトリやインクルードするファイルと同じディ
レクトリ以外のディレクトリに置かれている場合には，次のようにパス指定を
行う．

・ターゲット依存部（target/<ターゲット名>）のディレクトリに置かれている
　場合は，パス指定を行わず，ファイル名のみを記述する．
		例）#include "target_config.h"

・archディレクトリ下のディレクトリに置かれている場合には，archディレク
　トリからの相対パスで記述する．
		例）#include "m68k_gcc/prc_config.h"

・その他の場合には，ソースプログラムのルートディレクトリ（configureが置
　かれているディレクトリ）からの相対パスで記述する．
		例）#include "pdic/upd72001/upd72001.h"

・カーネルを構成するファイルから，kernelディレクトリ下のヘッダファイル
　をインクルードする場合は，パス指定を行わず，ファイル名のみを記述する．
		例）#include "kernel_impl.h"

1.6. クリティカルセクションの出入処理の実現に関する制約

カーネル内で用いるクリティカルセクションの出入処理を実現する場合には，
次の2つの条件を満たすように実装しなければならない．

(1-6-1) 出入処理から抜けた時点では，割込みの禁止／許可が完了していなけ
ればならない．例えば，割込み禁止／許可命令を実行してから実際に割込みが
禁止／許可されるまで何命令か遅延するプロセッサの場合には，出入処理の中
にNOP命令を入れるなどの方法で，出入処理を抜けた時点では，割込みが禁止／
許可された状態になっていることを保証しなければならない．

(1-6-2) メモリ上のデータ構造が書き変わる可能性があることを，何らかの方
法でコンパイラに知らせなければならない．GNU開発環境では，次のいずれかの
方法でこの制約を満たすことができる．

(a) クリティカルセクションの出入処理の全体または出入処理の本質的な部分
	（具体的には，割込み禁止／許可する処理）を（インラインでない）通常
	の関数により実現する．

(b) クリティカルセクションの出入処理の本質的な部分をインラインアセンブ
	ラによって実現している場合には，そのインラインアセンブラのclobber変
	数リストに"memory"を追加する．

(c) クリティカルセクションの出入処理の本質的な部分が，マクロやインライ
	ン関数呼出しで実現している場合には，クリティカルセクションに入る処
	理の最後と出る処理の先頭に，Asm("":::"memory")という記述を入れる．

このような制約を設ける理由については，「TOPPERS/ASPカーネル 設計メモ」
の「カーネルのデータ構造に対するvolatile宣言について」の節を参照するこ
と．

２．システム構築環境のターゲット依存部

この章の説明は，GNU開発環境（GCC，GAS，BINUTILS，GNU Make）を用いること
を想定して記述してある．それ以外の開発環境を用いる場合には，開発環境に
あわせて修正する必要がある．

2.1. ターゲット略称とターゲット依存部のディレクトリ

新しいターゲット依存部を作成する時は，まず，ターゲット略称を定める．ター
ゲット略称は，システム略称と開発環境略称を"_"で連結したものとする．シス
テム略称に用いる文字は英小文字と数字と"_"に，開発環境略称に用いる文字は
英小文字と数字に限定する．GNU開発環境の開発環境略称は，"gcc"とする．例
えば，システム略称が"dve68k"で，GNU開発環境を用いる場合には，ターゲット
略称は"dve68k_gcc"となる．

ターゲット依存部のファイルを置くために，targetディレクトリの下に，ター
ゲット略称を名称とするディレクトリを作成する．これをターゲット依存部ディ
レクトリと呼ぶ．

ターゲット依存部からプロセッサ依存部やチップ依存部を切り分ける場合には，
依存部略称を定める．依存部略称は，プロセッサやチップの略称と開発環境略
称を"_"で連結したものとする．プロセッサやチップの略称に用いる文字は，英
小文字と数字と"_"に限定する．例えば，プロセッサ略称が"m68k"で，GNU開発
環境を用いる場合には，依存部略称は"m68k_gcc"となる．

また，ターゲット依存部から開発環境依存部を切り分ける場合には，開発環境
略称を依存部略称とする．例えば，GNU開発環境依存部の依存部略称は，"gcc"
となる．

これらの依存部のファイルを置くために，archディレクトリの下に，依存部略
称を名称とするディレクトリを作成する．

なお，GNU開発環境以外の開発環境を用いる場合には，コンフィギュレーション
スクリプト（configure），サンプルのMakefile（sample/Makefile），一部の
ユーティリティプログラム（utils/genoffset，utils/makedep）を，その開発
環境用に用意する必要がある場合がある．その場合には，これらのファイルを，
ターゲット依存部ディレクトリか開発環境依存部ディレクトリに置くものとす
る．また，開発環境用のプロジェクトファイルが必要な場合には，ターゲット
依存部ディレクトリに置くものとする．

2.2. Makefileのターゲット依存部

Makefileのターゲット依存部は，ターゲット依存部ディレクトリに置いた
Makefile.targetまたはそこからインクルードされるファイル（プロセッサ・チッ
プ・開発環境依存部で用意されるファイルなど）に含める．

2.3. 開発環境名とコマンド名の設定

開発環境名とコマンド名を設定するために，Makefileのターゲット依存部で次
の変数を定義する．

(2-3-1) TOOL					開発環境名

開発環境名に定義する．GNU開発環境を用いる場合には，gccに定義する．

(2-3-2) GCC_TARGET				GNU開発環境のターゲット名

GNU開発環境を用いる場合に，GNU開発環境をconfigureする場合に指定するター
ゲット名に定義する．ここで指定したターゲット名は，開発環境のコマンド名
の先頭に付与される文字列となる．例えば，GCC_TARGETをm68k-unknown-elfに
定義した場合には，コンパイラとしてm68k-unknown-elf-gccが使われる．この
変数が定義されない場合には，単なるgccが使われる．

(2-3-3) CC						Cコンパイラドライバの名称
(2-3-4) CXX						C++コンパイラドライバの名称
(2-3-5) AS						アセンブラの名称
(2-3-6) LD						リンカの名称
(2-3-7) AR						アーカイバの名称
(2-3-8) NM						nmプログラムの名称
(2-3-9) RANLIB					ranlibプログラムの名称
(2-3-10) OBJCOPY				objcopyプログラムの名称
(2-3-11) OBJDUMP				objdumpプログラムの名称

GNU開発環境以外の開発環境を用いる場合に，それぞれのコマンドの名称に定義
する．対応するコマンドがない場合や，コマンドパラメータが異なる場合には，
Makefile中でそのコマンドを呼び出している部分を変更する必要がある．

GNU開発環境では，これらはGCC_TARGETを用いて定義されるので，定義する必要
はない．

2.4. コンパイルオプションとオブジェクトファイルの設定

Makefileのターゲット依存部で以下で説明する変数を定義する時には，":="を
用いて，それまでの定義に追加する形で行う．例えば，コンパイラに対するそ
の他のオプションとして「-Wall -g -O2」を追加したい場合には，「COPTS :=
$(COPTS) -Wall -g -O2」という記述をMakefileのターゲット依存部に含める．

(2-4-1) COPTS				コンパイラに対するその他のオプション
(2-4-2) CDEFS				マクロ定義オプション（-Dオプション）
(2-4-3) INCLUDES			ヘッダファイルの置かれたディレクトリ指定オ
							プション（-Iオプション）
(2-4-4) LDFLAGS				リンカに対するその他のオプション
(2-4-5) LIBS				ライブラリリンク指定のためのオプション

ターゲットに依存して，すべてのソースファイルに共通するコンパイルオプショ
ンの追加が必要な場合には，オプションの種類毎に上に示した変数に定義する．

ほとんどの場合に，ターゲット依存部ディレクトリのMakefile.targetには，以
下の記述を含める必要がある．

----------------------------------------
INCLUDES := $(INCLUDES) -I$(TARGETDIR)
----------------------------------------

ここでTARGETDIRは，ターゲット依存部ディレクトリに定義されている．また
SRCDIRは，Makefileにおいて，ソースプログラムのルートディレクトリ
（configureが置かれているディレクトリ）に定義されている．

コンパイラの問題等で，警告メッセージが出ることを防げない状況以外では，
COPTSに-Werrorを追加することを推奨する．

----------------------------------------
COPTS := $(COPTS) -Werror
----------------------------------------

カーネルのコンパイル時に，dereferencing type-punned pointer will break
strict-aliasing rulesという警告が出る場合には，以下を追加するとよい．こ
の警告メッセージに関する詳細は，「TOPPERS/ASPカーネル 設計メモ」の「型
キャストに伴う警告メッセージ」の節を参照すること．

----------------------------------------
KERNEL_CFLAGS := $(KERNEL_CFLAGS) -fno-strict-aliasing
----------------------------------------

また，アセンブリ言語レベルの識別名が，C言語レベルの識別名の先頭に"_"が
付いたものになる場合には，CDEFSに-DTOPPERS_LABEL_ASMを追加する．

(2-4-6) SYSSVC_DIR			システムサービスのソースが置かれたディレクトリ
(2-4-7) SYSSVC_ASMOBJS		アセンブリ言語で記述されたシステムサービスの
							オブジェクト
(2-4-8) SYSSVC_COBJS		C言語で記述されたシステムサービスのオブジェクト
(2-4-9) SYSSVC_CFLAGS		システムサービスに対するコンパイルオプション
(2-4-10) SYSSVC_LIBS		システムサービスに対するライブラリリンク指定

ターゲットに依存して，システムサービス（システムログタスクやデバイスド
ライバなど）のソースが置かれたディレクトリ，システムサービスを構成する
オブジェクトファイルのリスト，それらをコンパイルする際に適用するコンパ
イルオプション，その構成に必要なライブラリリンク指定を追加する場合には，
上に示した変数に定義する．

(2-4-11) KERNEL_DIR			カーネルのソースが置かれたディレクトリ
(2-4-12) KERNEL_ASMOBJS		アセンブリ言語で記述されたカーネルのオブジェクト
(2-4-13) KERNEL_COBJS		C言語で記述されたカーネルのオブジェクト
(2-4-14) KERNEL_CFLAGS		カーネルに対するコンパイルオプション

ターゲットに依存して，カーネルのソースが置かれたディレクトリ，カーネル
を構成するオブジェクトファイルのリスト，それらをコンパイルする際に適用
するコンパイルオプションを追加する場合には，上に示した変数に定義する．

ほとんどの場合に，ターゲット依存部ディレクトリのMakefile.targetには，以
下の記述を含める必要がある．

----------------------------------------
KERNEL_DIR := $(KERNEL_DIR) $(TARGETDIR)
KERNEL_ASMOBJS := $(KERNEL_ASMOBJS) target_support.o
KERNEL_COBJS := $(KERNEL_COBJS) target_config.o target_timer.o
----------------------------------------

(2-4-15) CFG_TABS			コンフィギュレータに対するオプション

ターゲットに依存して，コンフィギュレータに対するオプションを追加する場
合には，上に示した変数に定義する．具体的には，コンフィギュレータの値取
得シンボルテーブルのターゲット依存部（target_def.csv）がある場合には，
それを指定するオプションを追加する必要がある．

ほとんどの場合に，ターゲット依存部ディレクトリのMakefile.targetには，以
下の記述を含める必要がある．

----------------------------------------
CFG_TABS := $(CFG_TABS) --cfg1-def-table $(TARGETDIR)/target_def.csv
----------------------------------------

(2-4-16) CFG1_OUT_LDFLAGS	cfg1_out.cに対するリンクオプション

ターゲットに依存して，cfg1_out.cをリンクする際に適用するオプションを追
加する場合には，上に示した変数に定義する．

(2-4-17) CFG_OBJS			システムコンフィギュレーションのためのオブ
							ジェクト

ターゲットに依存して，システムコンフィギュレーションのためのオブジェク
トファイルを（kernel_cfg.o以外に）追加する場合には，上に示した変数に定
義する．この場合，追加したオブジェクトファイルの作成ルール（コンパイル／
アセンブルルールと依存関係作成ルール）を，Makefileのターゲット依存部に
記述する必要がある．

(2-4-18) CFG2_OUT

ターゲットに依存して，コンフィギュレータのパス2でkernel_cfg.cと
kernel_cfg.h以外のファイルを生成する場合には，上に示した変数に定義する．

(2-4-19) OMIT_WARINIG_ALL
(2-4-20) OMIT_OPTIMIZATION

サンプルのMakefileでは，コンパイラに対するオプションに「-Wall -g -O2」
を追加する．-Wallを追加したくない場合には，Makefileのターゲット依存部で
OMIT_WARNING_ALLを"true"に定義する．-O2を追加したくない場合には，
Makefileのターゲット依存部でOMIT_OPTIMIZATIONを"true"に定義する．

2.5. リンク方法の設定

(2-5-1) LDSCRIPT				リンカスクリプトのファイル名

開発環境に標準のリンカスクリプトが使用できない場合には，ターゲット依存
部でリンカスクリプトを用意し，そのファイル名をこの変数に定義する．

(2-5-2) TEXT_START_ADDRESS		テキストセクションの先頭番地
(2-5-3) DATA_START_ADDRESS		データセクションの先頭番地

各セクションの先頭番地の指定が必要な場合には，これらの変数に先頭番地を
定義する．

(2-5-4) START_OBJS				先頭にリンクすべきモジュール名
(2-5-5) END_OBJS				最後にリンクすべきモジュール名

ターゲットによっては，ロードモジュールの先頭と最後にリンクすべきモジュー
ルを，ターゲット依存部で用意する必要がある．多くの場合，スタートアップ
モジュールをロードモジュールの先頭にリンクする必要がある．

ロードモジュールの先頭にリンクすべきプログラムがある場合には，Makefile
のターゲット依存部において，そのオブジェクトファイル名をSTART_OBJSに定
義し，それに対するコンパイルルールと依存関係作成ルールを定義する．ロー
ドモジュールの最後にリンクすべきモジュールがある場合には，そのオブジェ
クトファイル名をEND_OBJSに定義し，それに対するコンパイルルールと依存関
係作成ルールを定義する．また，標準のスタートアップモジュール（crt0.o）
をリンクしないように，LDFLAGSに-nostdlibを追加する必要がある．さら
に，-nostdlibをつけることで標準ライブラリがリンクされなくなるため，
LIBSに-lgccを追加しなければならない．

例えば，スタートアップモジュールのソースファイルがstart.Sの場合には，
Makefileのターゲット依存部に次のような記述を入れるとよい．

----------------------------------------
# スタートアップモジュールのオブジェクトファイル名
START_OBJS = start.o

# スタートアップモジュールのコンパイルルール
$(START_OBJS): %.o: %.S
	$(CC) -c $(CFLAGS) $(KERNEL_CFLAGS) $<

# スタートアップモジュールの依存関係作成ルール
$(START_OBJS:.o=.d): %.d: %.S
	@$(PERL) $(SRCDIR)/utils/makedep -C $(CC) $(MAKEDEP_OPTS) \
		-O "$(CFLAGS) $(KERNEL_CFLAGS)" $< >> Makefile.depend

# リンカに対するオプション
LDFLAGS := -nostdlib $(LDFLAGS)
LIBS := $(LIBS) -lgcc
----------------------------------------

また，GNU開発環境で，コンパイラに標準のcrtbegin.oとcrtend.oを用いる場合
には，Makefile のターゲット依存部に次のような記述を入れるとよい．

----------------------------------------
# オブジェクトファイル名
START_OBJS = $(shell $(CC) -print-file-name=crtbegin.o)
END_OBJS = $(shell $(CC) -print-file-name=crtend.o)

# 依存関係作成ルール
$(START_OBJS:.o=.d): %.d:
$(END_OBJS:.o=.d): %.d:

# リンカに対するオプション
LDFLAGS := -nostdlib $(LDFLAGS)
LIBS := $(LIBS) -lgcc
----------------------------------------

この場合，これらのファイルをコンパイルすることはないため，コンパイルルー
ルは不要である．また，依存関係作成ルールはダミーでよい（依存関係作成ルー
ルがないとエラーになる）．

(2-5-6) HIDDEN_OBJS				指定しなくてもリンクされるモジュール名

ロードモジュールにリンクすべきモジュールを，リンカに対するパラメータで
はなく，リンカスクリプト中に（例えば，GNU開発環境のリンカスクリプトの
STARTUPを使って）記述する場合には，そのオブジェクトファイル名を，
（START_OBJSまたはEND_OBJSではなく）HIDDEN_OBJSに定義し，それに対するコ
ンパイルルールと依存関係作成ルールを定義する．HIDDEN_OBJSに定義したモ
ジュールは，リンカに対するパラメータからは除外される．LIBSとLDFLAGSにつ
いては，START_OBJSまたはEND_OBJSを用いる場合と同様である．

例えば，スタートアップモジュールのソースファイルがstart.Sで，start.oを
リンクすることをリンカスクリプト中に記述する場合には，Makefileのターゲッ
ト依存部に次のような記述を入れるとよい．

----------------------------------------
# スタートアップモジュールのオブジェクトファイル名
HIDDEN_OBJS = start.o

# スタートアップモジュールのコンパイルルール
$(HIDDEN_OBJS): %.o: %.S
	$(CC) -c $(CFLAGS) $(KERNEL_CFLAGS) $<

# スタートアップモジュールの依存関係作成ルール
$(HIDDEN_OBJS:.o=.d): %.d: %.S
	@$(PERL) $(SRCDIR)/utils/makedep -C $(CC) $(MAKEDEP_OPTS) \
		-O "$(CFLAGS) $(KERNEL_CFLAGS)" $< >> Makefile.depend

# リンカに対するオプション
LDFLAGS := -nostdlib $(LDFLAGS)
LIBS := $(LIBS) -lgcc
----------------------------------------

2.6. 依存関係の定義

コンフィギュレータの各パスに対して，ターゲット依存のファイルへの依存関
係を定義する．具体的には，パス1，パス2，パス3が依存するファイルを，それ
ぞれcfg1_out.c，kernel_cfg.timestamp，$(OBJFILE)に対する依存関係の形で
記述する．

ほとんどの場合に，ターゲット依存部ディレクトリのMakefile.targetには，以
下の記述を含める必要がある．

----------------------------------------
cfg1_out.c: $(TARGETDIR)/target_def.csv
kernel_cfg.timestamp: $(TARGETDIR)/target.tf
$(OBJFILE): $(TARGETDIR)/target_check.tf
----------------------------------------

2.7. その他の設定

(2-7-1) CLEAN_FILES				cleanにより削除するファイル名

cleanにより削除するファイルをターゲット依存部で追加したい場合には，ファ
イル名をこの変数に追加定義する．

(2-7-2) REALCLEAN_FILES			realcleanにより削除するファイル名

realcleanにより削除するファイルをターゲット依存部で追加したい場合には，
ファイル名をこの変数に追加定義する．


３．TOPPERS共通定義のターゲット依存部

TOPPERS共通定義（t_stddef.h）のターゲット依存部は，target_stddef.hまた
はそこからインクルードされるファイル（プロセッサ・チップ・開発環境依存
部で用意されるヘッダファイルなど）に含める．

3.1. ターゲット識別マクロ

アプリケーションやシステムサービスでターゲットを識別するために，
"TOPPERS_"にシステム略称を大文字にした文字列を連結したもの（例えば，
"TOPPERS_DVE68K"）をマクロ定義する．

また，ターゲット依存部からプロセッサ依存部やチップ依存部を切り分けた場
合には，"TOPPERS_"に依存部略称を大文字にした文字列を連結したもの（例え
ば，"TOPPERS_M68K"）をマクロ定義する．

3.2. 整数型の最大値・最小値・ビット数

(3-2-1) INT_MAX				intに格納できる最大値（C90準拠）
(3-2-2) INT_MIN				intに格納できる最小値（C90準拠）
(3-2-3) UINT_MAX			unsigned intに格納できる最大値（C90準拠）
(3-2-4) LONG_MAX			longに格納できる最大値（C90準拠）
(3-2-5) LONG_MIN			longに格納できる最小値（C90準拠）
(3-2-6) ULONG_MAX			unsigned longに格納できる最大値（C90準拠）
(3-2-7) CHAR_BIT			char型のビット数（C90準拠）

整数型の最大値・最小値・ビット数を，これらのシンボルにマクロに定義する．

これらのマクロは，C90に準拠したものである．開発環境にC90に準拠した
limits.hが用意されている場合には，これらのマクロを定義することに代えて，
limits.hをインクルードすればよい．

3.3. サイズの指定された整数型，その最大値・最小値，整数定数を作るマクロ

(3-3-1) int8_t				符号付き8ビット整数（オプション，C99準拠）
(3-3-2) uint8_t				符号無し8ビット整数（オプション，C99準拠）
(3-3-3) int16_t				符号付き16ビット整数（C99準拠）
(3-3-4) uint16_t			符号無し16ビット整数（C99準拠）
(3-3-5) int32_t				符号付き32ビット整数（C99準拠）
(3-3-6) uint32_t			符号無し32ビット整数（C99準拠）
(3-3-7) int64_t				符号付き64ビット整数（オプション，C99準拠）
(3-3-8) uint64_t			符号無し64ビット整数（オプション，C99準拠）
(3-3-9) int128_t			符号付き128ビット整数（オプション，C99準拠）
(3-3-10) uint128_t			符号無し128ビット整数（オプション，C99準拠）
(3-3-11) int_least8_t		8ビット以上の符号付き整数（C99準拠）
(3-3-12) uint_least8_t		8ビット以上の符号無し整数（C99準拠）
(3-3-13) intptr_t			ポインタを格納できるサイズの符号付き整数（C99準拠）
(3-3-14) uintptr_t			ポインタを格納できるサイズの符号無し整数（C99準拠）
(3-3-15) INT8_MAX			int8_tに格納できる最大値（オプション，C99準拠）
(3-3-16) INT8_MIN			int8_tに格納できる最小値（オプション，C99準拠）
(3-3-17) UINT8_MAX			uint8_tに格納できる最大値（オプション，C99準拠）
(3-3-18) INT16_MAX			int16_tに格納できる最大値（C99準拠）
(3-3-19) INT16_MIN			int16_tに格納できる最小値（C99準拠）
(3-3-20) UINT16_MAX			uint16_tに格納できる最大値（C99準拠）
(3-3-21) INT32_MAX			int32_tに格納できる最大値（C99準拠）
(3-3-22) INT32_MIN			int32_tに格納できる最小値（C99準拠）
(3-3-23) UINT32_MAX			uint32_tに格納できる最大値（C99準拠）
(3-3-24) INT64_MAX			int64_tに格納できる最大値（オプション，C99準拠）
(3-3-25) INT64_MIN			int64_tに格納できる最小値（オプション，C99準拠）
(3-3-26) UINT64_MAX			uint64_tに格納できる最大値（オプション，C99準拠）
(3-3-27) INT128_MAX			int128_tに格納できる最大値（オプション，C99準拠）
(3-3-28) INT128_MIN			int128_tに格納できる最小値（オプション，C99準拠）
(3-3-29) UINT128_MAX		uint128_tに格納できる最大値（オプション，C99準拠）
(3-3-30) INT_LEAST8_MAX		int_least8_tに格納できる最大値（C99準拠）
(3-3-31) INT_LEAST8_MIN		int_least8_tに格納できる最小値（C99準拠）
(3-3-32) UINT_LEAST8_MAX	uint_least8_tに格納できる最大値（C99準拠）
(3-3-33) INT8_C(val)		int_least8_t型の定数を作るマクロ（C99準拠）
(3-3-34) UINT8_C(val)		uint_least8_t型の定数を作るマクロ（C99準拠）
(3-3-35) INT16_C(val)		int16_t型の定数を作るマクロ（C99準拠）
(3-3-36) UINT16_C(val)		uint16_t型の定数を作るマクロ（C99準拠）
(3-3-37) INT32_C(val)		int32_t型の定数を作るマクロ（C99準拠）
(3-3-38) UINT32_C(val)		uint32_t型の定数を作るマクロ（C99準拠）
(3-3-39) INT64_C(val)		int64_t型の定数を作るマクロ（オプション，C99準拠）
(3-3-40) UINT64_C(val)		uint64_t型の定数を作るマクロ（オプション，C99準拠）
(3-3-41) INT128_C(val)		int128_t型の定数を作るマクロ（オプション，C99準拠）
(3-3-42) UINT128_C(val)		uint128_t型の定数を作るマクロ（オプション，C99準拠）

指定されたサイズの整数型を，これらのシンボルに型定義する．また，データ
型に格納できる最大値・最小値と，整数定数を作るマクロを，これらのシンボ
ルにマクロ定義する．

これらのデータ型およびマクロは，C99に準拠したものである．開発環境にC99
に準拠したstdint.hが用意されている場合には，これらのデータ型およびマク
ロを定義することに代えて，stdint.hをインクルードすればよい．

上でオプションと記述したものは，該当するデータ型がコンパイラでサポート
されている場合にのみ定義することを示す．

3.4. サイズの指定された浮動小数点型，その最大値・最小値のマクロ

(3-4-1) float32_t			IEEE754準拠の32ビット単精度浮動小数点数（オプ
							ション）
(3-4-2) double64_t			IEEE754準拠の64ビット倍精度浮動小数点数（オプ
							ション）
(3-4-3) FLOAT32_MIN			float32_tに格納できる最小の正規化された正の浮
							動小数点数（オプション）
(3-4-4) FLOAT32_MAX			float32_tに格納できる表現可能な最大の有限浮動
							小数点数（オプション）
(3-4-5) DOUBLE64_MIN		double64_tに格納できる最小の正規化された正の浮
							動小数点数（オプション）
(3-4-6) DOUBLE64_MAX		double64_tに格納できる表現可能な最大の有限浮動
							小数点数（オプション）

指定されたサイズ・表現形式の浮動小数点型を，これらのシンボルに型定義す
る．また，データ型に格納できる最大値・最小値を，これらのシンボルにマク
ロ定義する．

いずれも，該当するデータ型がコンパイラでサポートされている場合にのみ定
義する．

3.5. コンパイラの拡張機能のためのマクロ定義

コンパイラの拡張機能を用いるためのマクロとして，必要に応じて，以下のマ
クロの定義を含める．

(3-5-1) inline（オプション，デフォルトは未定義）
(3-5-2) Inline（オプション，デフォルトはstatic inline）

インライン関数であることを示す指定．Inlineは，コンパイル単位にローカル
なインライン関数であることを示す．

(3-5-3) asm（オプション，デフォルトは未定義）
(3-5-4) Asm（オプション，デフォルトは未定義）

インラインアセンブラを記述するための指定．Asmは，最適化により削除しては
ならないことを示す．これらは，ターゲット依存部でのみ使うマクロであるた
め，ターゲット依存部で使わないなら定義する必要はない．

(3-5-5) offsetof(structure, field)（オプション，デフォルトの定義あり）

構造体structureの中での，フィールドfieldのオフセットを求めるマクロ．

(3-5-6) alignof(type)（オプション，デフォルトの定義あり）

データ型typeのアラインメント単位を求めるマクロ．

(3-5-7) NoReturn（オプション，デフォルトは未定義）

リターンすることのない関数であることを示す指定．これは，ターゲット依存
部のみ使うマクロであるため，ターゲット依存部で使わないなら定義する必要
はない．

3.6. 標準的な定義の上書き

t_stddef.hに含まれるTOPPERS共通定義の標準的な定義を上書きする場合には，
以下のマクロを定義する．

(3-6-1) TOPPERS_bool（オプション，デフォルトはint）
(3-6-2) TOPPERS_size（オプション，デフォルトはuintptr_t）
(3-6-3) TOPPERS_fp（オプション，デフォルトは他と互換性のない関数ポインタ）

それぞれ，bool_t，SIZE，FPに型定義すべきデータ型．

(3-6-4) UINT_C(val)（オプション，デフォルトはUを付加）
(3-6-5) ULONG_C(val)（オプション，デフォルトはULを付加）

それぞれ，unsigned uint型，unsigned long型の定数を作るためのマクロ．

(3-6-6) NULL（オプション，デフォルトは0）

C90準拠のC言語環境では，NULLの定義はstddef.hに含まれているため，これを
インクルードしてもよい．

(3-6-7) ERCD(mercd, sercd)（オプション）
(3-6-8) MERCD(ercd)（オプション）
(3-6-9) SERCD(ercd)（オプション）

ERCD，MERCD，SERCDの標準の定義は，符号付き整数が2の補数で表現されており，
右シフト演算子（>>）が算術シフトされることを仮定している．多くのコンパ
イラでこの仮定が成り立つが，そうでない場合には，ターゲット依存部でこれ
らの定義を上書きする必要がある．

(3-6-10) ALIGN_TYPE(addr, type)（オプション）

アドレスaddrが，データ型typeのアラインメント単位にアラインしているか
チェックするマクロ．

3.7. アサーションのための定義

t_stddef.hには，assertの定義が含まれる．assertが失敗した場合（assertの
パラメータがfalseになった場合）の処理を，ターゲット依存に用意する必要が
ある．これらの定義は，assertマクロを使用する前であれば，t_stddef.h以降
にインクルードされるファイルに含まれていてもよい．なお，assertを無効に
する（NDEBUGをマクロ定義してコンパイルする）場合には，これらを用意する
必要はない．

(3-7-1) TOPPERS_assert_abort(void)

assertが失敗した場合に，プログラムを停止させる関数．システム開発中はデ
バッガに落とすのが理想的である．システム稼働時には例外処理を行わせるこ
とになる．

(3-7-2) TOPPERS_assert_fail(exp, file, line)

assertが失敗した時の情報を表示/記録するためのマクロ．システムログ機能を
用いる場合には，t_syslog.hにシステムログ機能に記録するための定義が含ま
れているので，ターゲット依存部で用意する必要はない．


４．システムインタフェースレイヤ（SIL）のターゲット依存部

システムインタフェースレイヤ（SIL，sil.h）のターゲット依存部の定義は，
target_sil.hまたはそこからインクルードされるファイル（プロセッサ・チッ
プ・開発環境依存部で用意されるヘッダファイルなど）に含める．

SILのサービスコールは，任意のシステム状態で呼び出すことができる．そのた
め，SILのターゲット依存部の関数は，任意のシステム状態で呼び出せるように
実装しなければならない．

4.1. 全割込みロック状態の管理

SILのターゲット依存部では，全割込みロック状態へ遷移する機能と，元の状態
へ戻す機能（元の状態を記憶するために変数を使う）を提供する．全割込みロッ
ク状態であるかを判別する機能は提供する必要がない．

SILの機能は，カーネルを使用しない場合にも使用できる必要がある．そのため，
全割込みロック状態への遷移と元の状態への復帰は，カーネルを用いず，プロ
セッサのリソースを直接操作することによって実現する．また，全割込みロッ
ク状態への遷移と元の状態への復帰は，全割込みロック状態やCPUロック状態で
も行える必要がある．

保護機能を持ったカーネルでは，ユーザタスクからプロセッサのリソースを直
接操作することができないため，ユーザタスクからはこれらの機能を用いるこ
とができない．用いた場合の振舞いはターゲットプロセッサに依存するが，典
型的には，特権命令違反などのCPU例外が発生することになる．

(4-1-1) SIL_PRE_LOC

全割込みロックフラグの状態を保存するための変数を定義するマクロ．型名の
後に，変数名を続けたものに定義する．変数名は，他の名前と衝突しないよう
に，"TOPPERS_"で始まる名前にする．

(4-1-2) SIL_LOC_INT()

現在の全割込みロックフラグの状態をSIL_PRE_LOCで定義した変数に保存し，全
割込みロック状態に遷移させるマクロ．このマクロを実現する際には，「1.6
クリティカルセクションの出入処理の実現に関する制約」の節に記述されてい
る制約に従わなければならない．

(4-1-3) SIL_UNL_INT()

SIL_LOC_INT()によって変数に保存した状態に戻すマクロ．このマクロを実現す
る際には，「1.6 クリティカルセクションの出入処理の実現に関する制約」の
節に記述されている制約に従わなければならない．

4.2. 微少時間待ち

(4-2-1) void sil_dly_nse(ulong_t dlytim)

dlytimで指定された以上の時間（単位はナノ秒），ループなどによって待つ関
数．

以下の関数と等価な処理を，アセンブリ言語で記述する方法を，標準的な実装
方法とする．アセンブリ言語で記述するのは，コンパイラの最適化に依存しな
いようにするためである．またこの関数は，キャッシュ等の影響を受けないよ
うに，できる限りメモリアクセスを行わないように実装すべきである．

	void sil_dly_nse(ulong_t dlytim)
	{
		dlytim -= SIL_DLY_TIM1;
		if (結果が0より大きい) {
			do {
				dlytim -= SIL_DLY_TIM2;
			} while (結果が0より大きい);
		}
	}

この関数の動作は次の通りである．dlytimがSIL_DLY_TIM1以下の場合には，最
初のif文の条件が成立せず，すぐに関数から抜ける．dlytimがSIL_DLY_TIM1よ
り大きく，(SIL_DLY_TIM1+SIL_DLY_TIM2)以下の場合には，最初のif文の条件は
成立するが，doループは1回も回らずに関数から抜ける．dlytimが
(SIL_DLY_TIM1+SIL_DLY_TIM2)より大きく，(SIL_DLY_TIM1+SIL_DLY_TIM2*2)以
下の場合には，doループを1回だけ回って関数から抜ける．その後，dlytimが
SIL_DLY_TIM2大きくなる度に，whileループを回る回数が1回ずつ増える．

なお，この関数をアセンブリ言語（または，C言語）で記述する場合，どのファ
イルに記述するかが問題になる．SILのターゲット依存部には，標準では，アセ
ンブリ言語（または，C言語）の関数定義を記述するためのファイルを用意して
いない．ターゲット依存で用意してもよいが，例外的に，カーネル実装のター
ゲット依存モジュール（target_support.Sまたはtarget_config.c）に記述して
もよいことにする．

(4-2-2) SIL_DLY_TIM1（オプション）
(4-2-3) SIL_DLY_TIM2（オプション）

sil_dly_nseを上記の標準的な方法で実現した場合，この2つの定数をターゲッ
ト依存部でマクロ定義する．

SIL_DLY_TIM2は，上記の関数において，doループ1回の実行時間（単位はナノ秒）
に設定する．ターゲットプロセッサの命令セットにもよるが，おおよそ，減算
命令と条件分岐命令各1回の実行時間になる．SIL_DLY_TIM2が決まれば，関数呼
出しも含めた全体の時間がdlytimで指定された以上の時間になるように，
SIL_DLY_TIM1を決める．

※下記の内容は，現時点でSSPカーネルでは未サポートである．

この2つの定数値の決定を支援するプログラムとして，testディレクトリに，
test_dlynseを用意している．test_dlynseを実行すると，次のような出力が得
られる．

-- for fitting parameters --
sil_dly_nse(0): 430 OK
sil_dly_nse(420): 430 OK
sil_dly_nse(510): 520 OK
sil_dly_nse(600): 610 OK
<中略>
-- for checking boundary conditions --
sil_dly_nse(421): 520 OK
sil_dly_nse(511): 610 OK
sil_dly_nse(601): 700 OK

"for fitting parameters"に続く出力は，sil_dly_nse(dlytim)を呼び出した場
合の待ち時間を測定した結果である．このプログラムを用いて，":"の右側の数
値が，dlytimよりも大きい範囲でなるべく近い値になるように，2つの定数値を
調整する．"for checking boundary conditions"に続く出力は，プログラムの
妥当性をチェックするためのもので，":"の右側の数値が，dlytimよりも大きい
ことを確認する（近い値になる必要はない）．

4.3. プロセッサのエンディアン

(4-3-1) SIL_ENDIAN_BIG
(4-3-2) SIL_ENDIAN_LITTLE

プロセッサのエンディアンにより，いずれか片方のシンボルをマクロ定義する．

(4-3-3) TOPPERS_SIL_REV_ENDIAN_UINT16（オプション）
(4-3-4) TOPPERS_SIL_REV_ENDIAN_UINT32（オプション）

それぞれ，16ビット，32ビットの符号無し整数のエンディアンを反転させるマ
クロ．プロセッサがエンディアン反転のための命令を持つ場合には，その命令
を用いて実現する．これらのシンボルをマクロ定義しない場合には，デフォル
トの定義が使われる．

4.4. メモリ空間アクセス関数

(4-4-1) TOPPERS_OMIT_SIL_ACCESS

標準のメモリ空間アクセス関数を使用せず，ターゲット依存部で用意する場合
には，このシンボルをマクロ定義する．

(4-4-2) TOPPERS_OMIT_SIL_REH_LEM
(4-4-3) TOPPERS_OMIT_SIL_WRH_LEM
(4-4-4) TOPPERS_OMIT_SIL_REH_BEM
(4-4-5) TOPPERS_OMIT_SIL_WRH_BEM
(4-4-6) TOPPERS_OMIT_SIL_REW_LEM
(4-4-7) TOPPERS_OMIT_SIL_WRW_LEM
(4-4-8) TOPPERS_OMIT_SIL_REW_BEM
(4-4-9) TOPPERS_OMIT_SIL_WRW_BEM

それぞれ，標準のsil_reh_lem，sil_wrh_lem，sil_reh_bem，sil_wrh_bem，
sil_rew_lem，sil_wrw_lem，sil_rew_bem，sil_wrw_bemを使用せず，ターゲッ
ト依存部で用意する場合には，これらのシンボルをマクロ定義する．

4.5. I/O空間アクセス関数

メモリ空間とは別にI/O空間を持つプロセッサでは，I/O空間にあるデバイスレ
ジスタをアクセスするための関数として，sil_reb_iop，sil_wrb_iop，
sil_reh_iop，sil_wrh_iop，sil_reh_lep，sil_wrh_lep，sil_reh_bep，
sil_wrh_bep，sil_rew_iop，sil_wrw_iop，sil_rew_lep，sil_wrw_lep，
sil_rew_bep，sil_wrw_bepの中で必要なものを，ターゲット依存部で用意する．


５．カーネルAPIのターゲット依存部

カーネルAPI（kernel.h）のターゲット依存部の定義は，target_kernel.hまた
はそこからインクルードされるファイル（プロセッサ・チップ・開発環境依存
部で用意されるヘッダファイルなど）に含める．

5.1. ターゲット定義でサポートする機能

(5-1-1) TOPPERS_TARGET_SUPPORT_DIS_INT		dis_intをサポートする
(5-1-2) TOPPERS_TARGET_SUPPORT_ENA_INT		ena_intをサポートする

dis_int，ena_int，サポートする場合に，それぞれのシンボルをマク
ロ定義する．

5.2. 割込み優先度の範囲

(5-2-1) TMIN_INTPRI				割込み優先度の最小値（最高値）
(5-2-2) TMAX_INTPRI				割込み優先度の最大値（最低値）

それぞれ，カーネル管理の割込み優先度の最小値（＝優先度が最高），カーネ
ル管理の割込み優先度の最大値（優先度が最低）に定義する．TMAX_INTPRIは-1
に固定されているが，対称性のために，ターゲット依存部で定義することにし
ている．

5.3. タイムティックの定義

(5-3-1) TIC_NUME				タイムティックの周期の分子
(5-3-2) TIC_DENO				タイムティックの周期の分母

タイムティックの周期（signal_timeを呼び出す周期）を，ミリ秒単位で，
TIC_NUME/TIC_DENOに定義する．例えば，タイムティックの周期が1/30秒の場合
には，TIC_NUMEを100に，TIC_DENOを3に定義すればよい．

タイムティックの周期は，1ミリ秒とする（つまり，TIC_NUME，TIC_DENOとも1
に定義する）ことを推奨するが，シミュレーション環境や性能の低いプロセッ
サでそれが適切でない場合には，それ以外の値としてもよい．その場合でも，
可能な限り，1ミリ秒の倍数である（つまり，TIC_DENOを1に定義する）ことが
望ましい．

TIC_NUMEとTIC_DENOの定義を変更することで，タイムティックの周期を変更で
きるようにタイマドライバを実装する場合には，この2つの定数の定義はデフォ
ルト値を与えていることになる．そこで，これらの定義を「#ifndef TIC_NUME」
「#endif」で囲んで記述する．

5.4. メモリ領域確保のための型定義

(5-4-1) TOPPERS_STK_T	スタック領域を確保するための型（オプション）

スタック領域は，標準では，intptr_t型の配列として確保するが，より大きい単位で
アラインさせたいなどの理由で，それ以外の型の配列として確保する場合には，
それぞれTOPPERS_STK_Tとを，配列のベースとなるデータ型にマクロ定義する．

5.5. メモリ領域確保のためのマクロ

(5-5-1) TOPPERS_ROUND_SZ（オプション）
(5-5-2) TOPPERS_COUNT_SZ（オプション）

TOPPERS_COUNT_SZ(sz, unit)は，sz/unitを切り上げた値を求めるマクロで，サ
イズがszのメモリ領域をサイズがunitのデータ型の配列で確保する場合の要素
数を求めるために用いる．TOPPERS_ROUND_SZ(sz, unit)は，sz/unitを切り上げ
たものにunitをかけた値を求めるマクロで，サイズがszのメモリ領域をサイズ
がunitのデータ型の配列で確保する場合のトータルサイズを求めるために用い
る．

それぞれ，標準のTOPPERS_ROUND_SZ，TOPPERS_COUNT_SZが適切でなく，ターゲッ
ト依存部で用意する場合には，これらのシンボルを適切な値にマクロ定義する．

６．カーネル実装のターゲット依存部

6.1. カーネル実装のターゲット依存部の共通事項

6.1.1. カーネル実装のターゲット依存部の構成要素

カーネル実装のターゲット依存部は，以下の要素で構成される．

(a) カーネル実装のターゲット依存の定義

カーネル実装のターゲット非依存部から参照されるターゲット依存の定義は，
target_config.hまたはそこからインクルードされるファイル（プロセッサ・チッ
プ・開発環境依存部で用意されるヘッダファイルなど）に含める．

ターゲットのハードウェア資源（割込みハンドラ番号やCPU例外ハンドラ番号，
デバイスレジスタの番地など）の定義は，システムサービスやアプリケーショ
ンにも有用であるため，カーネル実装のみに有用な定義を含むファイルとは切
り分けて，独立したヘッダファイルに含める．このヘッダファイルの標準的な
名称を，システム略称.h（または，チップ略称.h，プロセッサ略称.h）とする．

(b) カーネル実装のターゲット依存モジュール

カーネル実装のターゲット依存の変数定義や関数を含むモジュール．C言語で記
述される部分をtarget_config.c，アセンブリ言語で記述される部分を
target_support.Sに含める．プロセッサ・チップ・開発環境依存部を切り分け
ることや，ファイルが大きくなる場合に複数のファイルに分割することも可能
である．

(c) カーネル実装のターゲット依存部のためのリネーム記述

カーネル実装のターゲット依存部の変数名や関数名を，先頭に_kernel_を付与
した名前にリネームするためのモジュール．target_rename.defを用意し，ツー
ル（utils/genrename）により，target_rename.hとtarget_unrename.hを生成す
る．プロセッサ・チップ・開発環境依存部を切り分ける場合には，リネーム記
述も切り分ける．

※
(d) タイマドライバ

カーネルにタイムティックを通知する（signal_timeを周期的に呼び出す）ため
のタイマドライバのヘッダファイル，実装ファイル，システムコンフィギュレー
ションファイルを，それぞれ，target_timer.h，target_timer.c，
target_timer.cfgに含める．プロセッサ・チップ・開発環境依存部を切り分け
ることも可能である．

(e) コンフィギュレータ設定ファイル

コンフィギュレータの設定ファイルのターゲット依存部を，target_def.csv，
target.tf，target_check.tfに用意する．コンフィギュレータ設定ファイルの
記述方法については，７章で説明する．

6.1.2. ターゲット依存部の関数の命名規則

カーネル実装のターゲット依存部を構成する関数の中で，t_で始まるものはタ
スクコンテキスト専用，i_で始まるものは非タスクコンテキスト専用，x_で始
まるものはいずれのコンテキストからでも呼び出すことができる関数である．

6.2. システム状態の管理

SSPカーネルを新たなターゲットシステムにポーティングする際に，最も重要な
作業は，カーネルが定義するシステム状態を，ハードウェア（プロセッサ）上
でどのように実現するかである．以下の説明は，TOPPERS新世代カーネルにおけ
るシステム状態の定義・意味を知っていることを前提に記述している．

6.2.1. 全割込みロック状態の管理

全割込みロック状態は，NMIを除くすべての割込みをマスクした状態である．全
割込みロック状態を管理する機能は，システムインタフェースレイヤ（SIL）に
よって提供され，カーネルは全割込みロック状態を管理しない．

全割込みロック状態では，sns_kerとext_ker以外のカーネルのサービスコール
を呼ぶことはできないものとしており，呼んだ場合には何が起こるか保証して
いない．sns_kerとext_kerから呼び出す処理は，トレースログ取得処理とSILの
サービスコールを除くと，call_exit_kernelのみである．そのため，
call_exit_kernelから呼び出すものを除いて，カーネルのターゲット依存部の
関数が，全割込みロック状態で呼び出される状況は考える必要がない．

6.2.2. コンテキストの管理

処理単位が実行されるコンテキストは，タスクコンテキストと非タスクコンテ
キストに分類される．

ターゲット依存部は，実行中の処理単位が，タスクコンテキストで実行されて
いるか非タスクコンテキストで実行されているかを判別する機能を提供する．
また，CPU例外が発生したコンテキストについて判別する機能を提供する．

ターゲット依存部では，割込みハンドラとCPU例外ハンドラの入口処理で非タス
クコンテキストに切り換え，それらの出口処理で元のコンテキストに戻す．ま
た，ディスパッチャの内部で一時的に非タスクコンテキストに切り換える．

(6-2-2-1) bool_t sense_context(void)

実行中の処理単位が，タスクコンテキストで実行されている場合にはfalse，非
タスクコンテキストで実行されている場合にはtrueを返す関数．この関数は，
CPUロック状態でもCPUロック解除状態でも呼び出せるように実装しなければな
らない．

6.2.3. CPUロック状態の管理

ターゲット依存部は，CPUロック状態へ遷移する機能，CPUロック解除状態へ遷
移する機能，CPUロック状態であるかを判別する機能を提供する．

(6-2-3-1) void t_lock_cpu(void)
(6-2-3-2) void i_lock_cpu(void)
(6-2-3-3) void x_lock_cpu(void)

CPUロック解除状態から，CPUロック状態へ遷移させる関数．これらの関数は，
CPUロック状態で呼び出されることはなく，呼び出された場合の動作は保証する
必要がない．

これらの関数を実現する際には，「1.6 クリティカルセクションの出入処理の
実現に関する制約」の節に記述されている制約に従わなければならない．

(6-2-3-4) void t_unlock_cpu(void)
(6-2-3-5) void i_unlock_cpu(void)
(6-2-3-6) void x_unlock_cpu(void)

CPUロック状態から，CPUロック解除状態へ遷移させる関数．これらの関数は，
CPUロック解除状態で呼び出されることはなく，呼び出された場合の動作は保証
する必要がない．

タスクコンテキストでCPUロック状態に遷移した場合には，CPUロック解除状態
に戻るのはタスクコンテキストに限られ，非タスクコンテキストでCPUロック解
除状態に戻ることはない．言い換えると，t_unlock_cpuが呼び出されるのは，
t_lock_cpuによってCPUロック状態になっている時である．i_lock_cpuによって
CPUロック状態になっている時には，t_unlock_cpuが呼び出されることはない．

同様に，非タスクコンテキストでCPUロック状態に遷移した場合には，CPUロッ
ク解除状態に戻るのは非タスクコンテキストに限られ，タスクコンテキストで
CPUロック解除状態に戻ることはない．言い換えると，i_unlock_cpuが呼び出さ
れるのは，i_lock_cpuによってCPUロック状態になっている時である．
t_lock_cpuによってCPUロック状態になっている時には，i_unlock_cpuが呼び出
されることはない．

これらの関数を実現する際には，「1.6 クリティカルセクションの出入処理の
実現に関する制約」の節に記述されている制約に従わなければならない．

(6-2-3-7) bool_t t_sense_lock(void)
(6-2-3-8) bool_t i_sense_lock(void)
(6-2-3-9) bool_t x_sense_lock(void)

現在のシステム状態が，CPUロック状態の場合はtrue，CPUロック解除状態の場
合にはfalseを返す関数．

これらの関数が全割込みロック状態で呼び出される状況は考える必要がないこ
とから，全割込みロック状態とCPUロック状態を区別できる必要はない．NMI以
外にカーネルの管理外の割込みを設けない場合には，全割込みロック状態と
CPUロック状態が全く同一の状態でもかまわない．

6.3. 割込みに関連するシステム状態の管理

6.3.1. 割込み優先度マスクの管理

ターゲット依存部は，割込み優先度マスクを設定する機能と，割込み優先度マ
スクを参照する機能を提供する．

(6-3-1-1) void x_set_ipm(PRI intpri)
(6-3-1-2) void t_set_ipm(PRI intpri)
(6-3-1-3) void i_set_ipm(PRI intpri)

割込み優先度マスクの値をintpriに設定する関数．

これらの関数は，CPUロック状態でもCPUロック解除状態でも呼び出せるように
実装するのが望ましい．ただし，x_set_ipmとt_set_ipmは，ターゲット非依存
部がCPUロック解除状態で呼び出すことはないため，CPUロック解除状態で呼び
出された場合の動作は保証する必要がない．i_set_ipmは，CPUロック状態でも
CPUロック解除状態でも呼び出せるように実装しなければならない．

また，これらの関数は，VALID_INTPRI_CHGIPM(intpri)がtrueを返すintpriに対
してのみ呼ばれる．intpriにそうでない値が渡された場合の動作は保証する必
要がない．

(6-3-1-4) PRI x_get_ipm(void)
(6-3-1-5) PRI t_get_ipm(void)
(6-3-1-6) PRI i_get_ipm(void)

割込み優先度マスクの値を参照して返す関数．

これらの関数は，CPUロック状態でもCPUロック解除状態でも呼び出せるように
実装するのが望ましい．ただし，x_get_ipmとt_get_ipmは，ターゲット非依存
部がCPUロック解除状態で呼び出すことはないため，CPUロック解除状態で呼び
出された場合の動作は保証する必要がない．i_get_ipmは，CPUロック状態でも
CPUロック解除状態でも呼び出せるように実装しなければならない．

割込み優先度マスクを用いてカーネル管理の割込みをすべてマスクした状態は，
CPUロック状態と区別できることが必要である．具体的には，CPUロック解除状
態において，x_set_ipmを用いてカーネル管理の割込みをすべてマスクした場合
でも，x_sense_lockはfalseを返す．

それに対して，割込み優先度マスクを用いてNMIを除くすべての割込みをマスク
できる場合，その状態と全割込みロック状態を区別できる必要はなく，全く同
一の状態でもかまわない．

6.3.2. 割込み要求禁止フラグの管理

ターゲット依存部は，割込み要求禁止フラグをセットする機能とクリアする機
能を提供する．

(6-3-2-1) bool_t VALID_INTNO_DISINT(INTNO intno)

intnoが，dis_int／ena_intに対する割込み番号として有効な値である場合に
true，そうでない場合にfalseを返すマクロ．割込み要求禁止フラグがセット／
クリアできないintnoに対しては，このマクロがfalseを返すようにする．

(6-3-2-2) bool_t x_disable_int(INTNO intno)
(6-3-2-3) bool_t t_disable_int(INTNO intno)
(6-3-2-4) bool_t i_disable_int(INTNO intno)

intnoで指定された割込み要求ラインに対する割込み要求禁止フラグをセットし，
trueを返す関数．指定された割込み要求ラインに対して，割込み属性が設定さ
れていない場合には，falseを返す．

これらの関数は，ターゲット非依存部がCPUロック解除状態で呼び出すことはな
いため，CPUロック解除状態で呼び出された場合の動作は保証する必要がない．
ただし，ターゲット依存部からCPUロック解除状態で呼び出す場合には，保証す
る必要がある．

また，これらの関数は，VALID_INTNO_DISINT(intno)がtrueとなるintnoに対し
てのみ呼ばれる．intnoにそうでない値が渡された場合の動作は保証する必要が
ない．

dis_intサービスコールをサポートする場合（TOPPERS_SUPPORT_DIS_INTをマク
ロ定義する場合）には，t_disable_intが用意されていなければならない．

(6-3-2-5) bool_t x_enable_int(INTNO intno)
(6-3-2-6) bool_t t_enable_int(INTNO intno)
(6-3-2-7) bool_t i_enable_int(INTNO intno)

intnoで指定された割込み要求ラインに対する割込み要求禁止フラグをクリアし，
trueを返す関数．指定された割込み要求ラインに対して，割込み属性が設定さ
れていない場合には，falseを返す．

これらの関数は，ターゲット非依存部がCPUロック解除状態で呼び出すことはな
いため，CPUロック解除状態で呼び出された場合の動作は保証する必要がない．
ただし，ターゲット依存部からCPUロック解除状態で呼び出す場合には，保証す
る必要がある．

また，これらの関数は，VALID_INTNO_DISINT(intno)がtrueとなるintnoに対し
てのみ呼ばれる．intnoにそうでない値が渡された場合の動作は保証する必要が
ない．

ena_intサービスコールをサポートする場合（TOPPERS_SUPPORT_ENA_INTをマク
ロ定義する場合）には，t_enable_intが用意されていなければならない．

6.3.3. 割込み要求のクリア

(6-3-3-1) void x_clear_int(INTNO intno)
(6-3-3-2) void t_clear_int(INTNO intno)
(6-3-3-3) void i_clear_int(INTNO intno)

intnoで指定された割込み要求ラインがエッジトリガである場合に，トリガされ
た割込み要求をクリアする関数．intnoで指定された割込み要求ラインがレベル
トリガである場合には何もしない．

SSPカーネルのターゲット非依存部では，これらの関数を呼び出していないが，
ターゲット依存部やシステムサービスで呼び出す可能性が高いため，用意する
こととしている．そのため，これらの関数がどのようなシステム状態で呼び出
せるかは，ターゲット依存部内で一貫していればよい．

6.3.4. 割込み要求のプローブ

(6-3-4-1) bool_t x_probe_int(INTNO intno)
(6-3-4-2) bool_t t_probe_int(INTNO intno)
(6-3-4-3) bool_t i_probe_int(INTNO intno)

intnoで指定された割込み要求ラインに対して，割込みが要求されている場合に
true，そうでない場合にfalseを返す関数．

SSPカーネルのターゲット非依存部では，これらの関数を呼び出していないが，
ターゲット依存部やシステムサービスで呼び出す可能性が高いため，用意する
こととしている．そのため，これらの関数がどのようなシステム状態で呼び出
せるかは，ターゲット依存部内で一貫していればよい．

6.3.5. 割込みハンドラの先頭処理と末尾処理

(6-3-5-1) void i_begin_int(INTNO intno)

intnoで指定された割込み要求ラインに対する割込みハンドラの先頭で行うべき
処理を行う関数．ここで行うべき処理としては，割込み要求ラインがエッジト
リガである場合のトリガされた割込み要求のクリアが挙げられる．

intnoに対して登録された割込みサービスルーチンを呼び出す割込みハンドラの
先頭で呼び出される．そのためこの関数は，割込みハンドラの先頭（通常は
CPUロック解除状態）で呼び出せるように実装しなければならない．

(6-3-5-2) void i_end_int(INTNO intno)

intnoで指定された割込み要求ラインに対する割込みハンドラの末尾で行うべき
処理を行う関数．ここで行うべき処理としては，割込みコントローラ（IRC）に
対する割込み処理の終了を通知が挙げられる．

intnoに対して登録された割込みサービスルーチンを呼び出す割込みハンドラの
末尾で呼び出される．そのためこの関数は，割込みハンドラの末尾（通常は
CPUロック解除状態）で呼び出せるように実装しなければならない．

6.4. タスクディスパッチャ


6.4.1. ディスパッチャの動作開始

(6-4-1-1) void start_dispatch(void)

ディスパッチャの動作開始（start_dispatch）は，カーネル起動時に，カーネ
ルの初期化処理から呼び出される．start_dispatchは，リターンすることのな
い関数である．

start_dispatchは，非タスクコンテキストで，NMIを除くすべての割込みをマス
クした状態（全割込みロック状態と同等の状態）で呼び出される．start_dispatch
内で，タスクコンテキストに切り換え，CPUロック状態・割込み優先度マスク全
解除状態にしなければならない．

コンテキストを切り替えた後はターゲット非依存部関数dispatcherを呼び出す．

start_dispatchの処理内容は次の通り．dispatcherから処理が返ることは考量する必要は
ない．

----------------------------------------
void
start_dispatch(void)
{
	タスクコンテキストに切り換える
	CPUロック状態・割込み優先度マスク全解除状態にする
	dispatcherに分岐する
}
----------------------------------------

6.5. 割込みハンドラ

6.5.1. 割込みハンドラの出入口処理

カーネル管理の割込みの出入口処理の方法は，プロセッサによって大きく異な
るが，おおよその処理内容は次の通り．

----------------------------------------
void
<割込みの出入口処理>(void)
{
	少なくともカーネル管理の割込みを禁止した状態にする … (*f)
	スクラッチレジスタをスタックに保存する
	if (タスクコンテキストで割込み発生) {
		非タスクコンテキストに切り換える
	}

	この割込みよりも優先度の高い割込みのみを受け付けられるようにして，
												CPUロック解除状態にする
#ifdef LOG_INH_ENTER
	log_inh_enter(割込みハンドラ番号);
#endif /* LOG_INH_ENTER */
	割込みハンドラを呼び出す
#ifdef LOG_INH_LEAVE
	log_inh_leave(割込みハンドラ番号);
#endif /* LOG_INH_LEAVE */

  ret_int:
	if (タスクコンテキストで割込み発生) {
		（少なくとも）カーネル管理の割込みを禁止した状態にする … (*d)
		if (reqflg) {
			reqflg = false;
			CPUロック状態にする … (*e)
			search_schedtskを呼び出し，最高優先順位タスクを求める
			最高優先順位のタスクIDを引数にしてrun_taskに分岐する
		}
	}
	割込み処理からのリターン後に，CPUロック解除状態に戻るように準備する
	スクラッチレジスタをスタックから復帰する
	割込み処理からのリターン
}
----------------------------------------

割込みの受付けによりすべての割込みが禁止されないプロセッサでは，(*f)に
おいて，少なくともカーネル管理の割込みを禁止する．この理由は次の通りで
ある．

割込みの入口処理において，スタックを非タスクコンテキスト用のスタックに
切り換える前に多重割込みが発生すると，タスクのスタック領域が使用される．
上記のようなプロセッサでは，スタックの切換え前に，最大で割込み優先度の
段数分の多重割込みが発生することを防ぐことはできず，各タスクのスタック
領域を確保する際に，その分を見込んで確保しなければならない．各タスクの
スタック領域をなるべく小さくするためには，スタックをなるべく使用しない
内に，多重割込みを禁止するのが望ましい．そのため，スクラッチレジスタを
スタックに保存する前に，割込みを禁止する．ただし，割込みの禁止処理に必
要な最低限のレジスタについては，割込みの禁止に先立ってスタックに保存す
る必要がある．

同様のことは，カーネル管理外の割込みにも当てはまる．すなわち，カーネル
管理外の割込みについても，スタックをなるべく使用しない内に禁止するのが
望ましい．このことから，カーネル管理外の割込みを使用する場合には，(*f)
において，すべての割込みを禁止した状態にするのが望ましいことになる．ま
た，カーネル管理外の割込み処理においても，非タスクコンテキスト用のスタッ
クに切り換えることが望ましいが，これはカーネルの管轄外である．

(*d)においては，カーネル管理の割込みを禁止するだけで，CPUロック状態にす
る必要はない．例えば，CPUロック状態であることを示す変数を用意している場
合には，(*d)の時点ではその変数をCPUロック状態を示す値に変更する必要はな
く，(*e)において変更すればよい．

割込みの出入口処理をアセンブリ言語で記述する場合には，トレースログ取得
処理は，「6.2 トレースログ機能への対応」の節で記述した方法でコーディン
グすること．

6.5.2. 割込みハンドラ毎の出入口処理の生成

割込みベクトルをハードウェアで実現している場合など，割込みハンドラ毎に
出入口処理を用意した方が効率が良いターゲットのために，割込みハンドラ毎
に出入口処理を生成する機構を用意している．

以下のマクロは，標準の割込み管理機能の初期化処理を用いた場合のみ，ター
ゲット非依存部で使われる．割込み管理機能の初期化処理をターゲット依存部
で用意し，その中でこれらのマクロを使わない場合には，これらのマクロを用
意する必要はない．

(6-5-2-1) INT_ENTRY(inhno, inthdr)

割込みハンドラ番号がinhno，割込みハンドラの関数名がinthdrである割込みハ
ンドラの出入口処理のラベルを作るマクロ．INTHDR_ENTRYを用いて割込みハン
ドラ毎に出入口処理を生成する場合には，次のように定義する．

#define INT_ENTRY(inhno, inthdr)	_kernel_##inthdr##_##inhno

割込みハンドラ毎に出入口処理を作る必要がない場合には，次のように定義し
て，割込みハンドラの関数名をそのまま返す．

#define INT_ENTRY(inhno, inthdr)	inthdr

(6-5-2-2) INTHDR_ENTRY(inhno, inhno_num, inthdr)

割込みハンドラ番号がinhno，割込みハンドラの関数名がinthdrである割込みハ
ンドラの出入口処理を生成するマクロ．inhno_numには，アセンブリ言語記述用
に，割込みハンドラ番号が数値で渡される．割込みハンドラ毎に出入口処理を
作る必要がない場合には，空に定義する．

6.5.3. 割込みハンドラの設定

(6-5-3-1) bool_t VALID_INHNO_DEFINH(INHNO inhno)（オプション）

inhnoが，DEF_INHに対する割込みハンドラ番号として有効な値である場合に
true，そうでない場合にfalseを返すマクロ．

SSPカーネルのターゲット非依存部では，このマクロは使われていないため，ター
ゲット依存部で使わないなら，用意する必要がない．

(6-5-3-2) void x_define_inh(INHNO inhno, FP int_entry)

inhnoで指定された割込みハンドラの出入口処理の番地をint_entryに設定する．

この関数は，標準の割込み管理機能の初期化処理を用いた場合のみ，ターゲッ
ト非依存部から呼び出される．割込み管理機能の初期化処理をターゲット依存
部で用意し，その中でこの関数を呼び出さない場合には，この関数を用意する
必要はない．

この関数は，ターゲット非依存部のカーネル初期化処理から呼び出されるため，
カーネルの初期化処理（NMIを除くすべての割込みがマスクされている）から呼
び出せるように実装すればよい．

指定された割込みハンドラ番号がDEF_INHに対するものとして有効な値でない場
合の動作は保証する必要がない（assertでエラーとするのが望ましい）．これ
は，コンフィギュレータが，パス2のテンプレートファイルのターゲット依存部
で定義するINHNO_DEFINH_VALIDを用いてエラーを検出するためである．

6.5.4. 割込み要求ラインの属性の設定

(6-5-4-1) bool_t VALID_INTNO_CFGINT(INTNO intno)（オプション）

intnoが，CFG_INTに対する割込み番号として有効な値である場合にtrue，そう
でない場合にfalseを返すマクロ．割込み要求ラインの属性を設定できない
intnoに対しては，このマクロがfalseを返すようにする．

SSPカーネルのターゲット非依存部では，このマクロは使われていないため，ター
ゲット依存部で使わないなら，用意する必要がない．

(6-5-4-2) void x_config_int(INTNO intno, ATR intatr, PRI intpri)

intnoで指定された割込み要求ラインの割込み属性を，intatrで指定された通り
に設定する．また，割込み優先度を，intpriで指定された値に設定する．

この関数は，標準の割込み管理機能の初期化処理を用いた場合のみ，ターゲッ
ト非依存部から呼び出される．割込み管理機能の初期化処理をターゲット依存
部で用意し，その中でこの関数を呼び出さない場合には，この関数を用意する
必要はない．

この関数は，ターゲット非依存部のカーネル初期化処理から呼び出されるため，
カーネルの初期化処理（NMIを除くすべての割込みがマスクされている）から呼
び出せるように実装すればよい．

intatrとして設定できる割込み属性は次の通り．

	TA_ENAINT		0x01	割込み要求禁止フラグをクリア
	TA_EDGE			0x02	エッジトリガ

この他に，ターゲット定義で割込み属性を追加してもよい．ターゲット定義で
追加するために，以下の属性名が予約されている．

	TA_POSEDGE				ポジティブエッジトリガ
	TA_NEGEDGE				ネガティブエッジトリガ
	TA_BOTHEDGE				両エッジトリガ
	TA_LOWLEVEL				ローレベルトリガ
	TA_HIGHLEVEL			ハイレベルトリガ

これらの属性名をターゲット定義で追加する場合には，その属性値を決定し，
定義をtarget_kernel.h（または，そこからインクルードされるファイル）に含
める．また，コンフィギュレータテンプレートファイルから参照できるように，
target_def.csv（または，そこからインクルードされるファイル）に含め，コ
ンフィギュレータテンプレートファイルのターゲット非依存部でエラーとなら
ないように，target.tf（または，そこからインクルードされるファイル）で
TARGET_INTATRに設定する．

指定された割込み番号がCFG_INTに対するものとして有効な値でない場合や，そ
の割込み要求ラインに対して設定できない属性を指定した場合，設定できない
割込み優先度を指定した場合の動作は保証する必要がない（assertでエラーと
するのが望ましい）．このようなケースは，コンフィギュレータでエラーを検
出すべきである．コンフィギュレータテンプレートファイルのターゲット非依
存部は，パス2のテンプレートファイルのターゲット依存部で定義する
INTNO_CFGINT_VALID，TARGET_INTATR，INTPRI_CFGINT_VALIDを用いてエラーを
検出するが，標準の割込み属性（TA_ENAINT，TA_EDGE）が設定できない場合や，
設定できない属性や割込み優先度が割込み要求ラインによって異なる場合には，
コンフィギュレータテンプレートファイルのターゲット依存部で検出しなけれ
ばならない．

6.5.5. 割込み管理機能の初期化処理の変更

(6-5-5-1) OMIT_INITIALIZE_INTERRUPT（オプション）

割込み管理機能の初期化処理をターゲット依存部で用意し，ターゲット非依存
部に含まれる標準の割込み管理機能の初期化処理を用いない場合には，このシ
ンボルをマクロ定義する．

このシンボルをマクロ定義すると，INHINIB，INTINIB，initialize_interrupt
の定義が，カーネルのターゲット非依存部から取り除かれる．また，
TNUM_INHNO，tnum_inhno，inhinib_table，TNUM_INTNO，tnum_intno，
intinib_tableの定義と，割込みハンドラ毎の出入口処理を生成するための記述
（INTHDR_ENTRYマクロのリスト）が，コンフィギュレータのパス2のテンプレー
トファイルのターゲット非依存部によってkernel_cfg.cに生成されなくなる．
ただし，コンフィギュレータのパス2のテンプレートファイルのターゲット依存
部で，USE_INHINIB_TABLEとUSE_INTINIB_TABLEを設定することで，その一部
分をkernel_cfg.cに生成することが可能である．

(6-5-5-2) void initialize_interrupt(void)（オプション）

OMIT_INITIALIZE_INTERRUPTをマクロ定義した場合には，この関数をターゲット
依存部で用意する．OMIT_INITIALIZE_INTERRUPTをマクロ定義することにより取
り除かれるその他のデータ型，変数，マクロは，この関数で使用する場合にの
み用意すればよい．

6.5.6. デフォルトの割込みハンドラ

(6-5-6-1) default_int_handler(void)（オプション）

コンフィギュレータにより割込みハンドラのテーブルを生成する場合などには，
割込みハンドラを登録しなかった割込みハンドラ番号に対して，デフォルトの
割込みハンドラとして，default_int_handlerを登録する．

default_int_handlerは，標準のものをターゲット依存部で用意するが，ユーザ
が用意したもので置き換えられるように，OMIT_DEFAULT_INT_HANDLERをマクロ
定義した場合には，ターゲット依存部で定義しないようにする．なお，ユーザ
が用意する場合の名称は，_kernel_default_int_handlerとなる．

6.5.7. カーネル管理外の割込み

カーネル管理外の割込みハンドラは，カーネル内の割込み出入口処理を経由せ
ずに実行するのが基本である．

ただし，すべての割込みで同じアドレスに分岐するプロセッサでは，カーネル
内の割込み出入口処理を全く経由せずにカーネル管理外の割込みハンドラを実
行することができないため，割込み出入口処理のなるべく早いタイミングで，
カーネル管理外の割込みであるかを判別し，処理内容を分ける必要がある．具
体的には，カーネル管理外の割込みの出入口処理では，オーバランハンドラの
停止と動作開始を行ってはならない．また，reqflgをチェックし，タスク切換
えやタスク例外処理ルーチンの呼出しを行う必要がない．さらに，NMIの出入口
処理では，トレースログ取得処理（log_inh_enterおよびlog_inh_leave）を呼
び出してはならない．

カーネル管理外の割込みハンドラを実行する際に，カーネル内の割込み出入口
処理の一部分を経由する場合には，CPU例外が起こる可能性を極力減らすととも
に，CPU例外を起こす可能性がある場合には，その可能性をターゲット依存部の
ユーザーズマニュアルに記載しなければならない．

次に，カーネル管理外の割込みの設定方法に関して，「TOPPERS新世代カーネル
統合仕様書」の「2.7.8 カーネル管理外の割込みの設定方法」の節の3つの方法
のいずれを採用するかを決定する．

(a-1)または(a-2)を採用し，カーネル管理外とした割込みに対して，カーネル
のAPIによる割込みハンドラの登録と割込み要求ラインの属性の設定をサポート
しない場合には，それに代わる方法をターゲット依存部のユーザーズマニュア
ルに記述する．

(a-1)または(a-2)を採用してカーネルのAPIによる割込みハンドラの登録や割込
み要求ラインの属性の設定をサポートする場合や，(b)を採用した場合には，ター
ゲット依存部においてそれを実現する必要がある．

カーネル管理外の割込みに対して，DEF_INHによる割込みハンドラの登録をサポー
トするには，次の設定が必要になる．

・TARGET_INHATRに，TA_NONKERNELを設定する．

・(a-1)または(a-2)を採用した場合には，INHNO_DEFINH_VALIDに，カーネル管
　理外とした割込みに対応する割込みハンドラ番号を含める．また，
　VALID_INHNO_DEFINHを，カーネル管理外とした割込みハンドラ番号を有効な
　値と判定するようにする．

・(a-1)または(a-2)を採用した場合には，INHNO_FIX_KERNELにカーネル管理と
　した割込みハンドラ番号のリストを，INHNO_FIX_NONKERNELにカーネル管理外
　とした割込みハンドラ番号のリスト設定する．

・DEF_INHがカーネル管理外の割込みに対応できるようにする．標準の割込み管
　理機能の初期化処理を用いる場合には，x_define_inhをカーネル管理外の割
　込みに対応させる．

・必要な場合には，TA_NONKERNEL属性が設定された割込みハンドラをカーネル
　管理外と扱うように，カーネル内の割込み出入口処理を修正する．標準の割
　込み管理機能の初期化処理を用いる場合，カーネル管理外の割込みに対して
　は，カーネル内の割込み出入口処理を生成せず，アプリケーションが登録し
　た割込みハンドラを直接呼び出すように，ターゲット非依存部により設定さ
　れるため，ターゲット依存部では対応する必要がない．

カーネル管理外の割込みに対して，CFG_INTによる割込み要求ラインの属性の設
定をサポートするには，次の設定が必要になる．

・(a-1)または(a-2)を採用した場合には，INTNO_CFGINT_VALIDに，カーネル管
　理外とした割込みに対応する割込み番号を含める．また，VALID_INTNO_CFGINT
　を，カーネル管理外とした割込み番号を有効な値と判定するようにする．

・(a-1)または(a-2)を採用した場合には，INTNO_FIX_KERNELにカーネル管理と
　した割込み番号のリストを，INTNO_FIX_NONKERNELにカーネル管理外とした割
　込み番号のリスト設定する．

・INTPRI_CFGINT_VALIDに，カーネル管理外の割込みとなる優先度を含める．

・CFG_INTがカーネル管理外の割込みに対応できるようにする．標準の割込み管
　理機能の初期化処理を用いる場合には，x_config_intをカーネル管理外の割
　込みに対応させる．

chg_ipmにより，（NMI以外の）カーネル管理外の割込みをマスクできるように
する場合には，次の設定が必要になる．

・VALID_INTPRI_CHGIPMを，カーネル管理外の割込みとなる優先度を有効な値と
　判定するようにする．

・t_set_ipmを，カーネル管理外の割込みとなる優先度を扱えるようにする．

6.6. CPU例外ハンドラとCPU例外発生時のシステム状態の参照

6.6.1. CPU例外ハンドラの出入口処理

CPU例外の出入口処理の方法はプロセッサによって大きく異なるが，おおよその
処理内容は次の通り．

----------------------------------------
void
<CPU例外の出入口処理>(void)
{
	スクラッチレジスタをスタックに保存する
	if (カーネル管理外のCPU例外) {
		if (タスクコンテキストでCPU例外発生) {
			非タスクコンテキストに切り換える
		}
		システム状態（コンテキストは除く）を，CPU例外発生時の状態にする
		CPU例外ハンドラを，CPU例外の情報を記憶している領域の先頭番地を
									パラメータ（p_excinf）として呼び出す
		if (タスクコンテキストでCPU例外発生) {
			タスクコンテキストに切り換える
		}
		CPU例外処理からのリターン後に，CPU例外発生時のシステム状態に
													戻るように準備する
	}
	else {
		if (タスクコンテキストでCPU例外発生) {
			非タスクコンテキストに切り換える
		}
		システム状態（コンテキストは除く）を，CPU例外発生時の状態にする
			　（CPU例外発生時の割込み優先度マスクよりも優先度の高い割込み
				のみを受け付けられるようにして，CPUロック解除状態にする）

#ifdef LOG_EXC_ENTER
		log_exc_enter(CPU例外ハンドラ番号);
#endif /* LOG_EXC_ENTER */
		CPU例外ハンドラを，CPU例外の情報を記憶している領域の先頭番地を
									パラメータ（p_excinf）として呼び出す
#ifdef LOG_EXC_LEAVE
		log_exc_leave(CPU例外ハンドラ番号);
#endif /* LOG_EXC_LEAVE */

	  ret_exc:
		if (タスクコンテキストでCPU例外発生) {
			（少なくとも）カーネル管理の割込みを禁止した状態にする … (*d)
			タスクコンテキストに切り換える
			if (reqflg) {
				reqflg = false;
				CPUロック状態にする … (*e)
				search_schedtskを呼び出し，最高優先順位タスクを求める
				最高優先順位のタスクIDを引数にしてrun_taskに分岐する
			}
		}
		CPU例外処理からのリターン後に，CPUロック解除状態に戻るように準備する
	}
	スクラッチレジスタをスタックから復帰する
	CPU例外処理からのリターン
}
----------------------------------------

CPU例外ハンドラは，非コンテキストに切り換えることを除いては，CPU例外発
生時と同じシステム状態で呼び出さなければならない．例えば，CPU例外がCPU
ロック状態で発生した場合にはCPUロック状態，CPUロック解除状態で発生した
場合にはCPUロック解除状態で，CPU例外ハンドラを呼び出さなければならない．
CPUロック状態で発生したCPU例外は，カーネル管理外のCPU例外となるため，カー
ネル管理のCPU例外ハンドラについては，CPUロック解除状態で呼び出すことに
なる．

カーネル管理外のCPU例外であることは，exc_sense_unlockがfalseを返す条件
と，タスクコンテキストであることを調べないだけの違いであり，ほぼ同じコー
ドで判定することができる．

上のコードでは，カーネル管理外のCPU例外に対して，トレースログ取得処理
（log_exc_enterおよびlog_exc_leave）を呼び出していないが，全割込みロッ
ク状態かNMIの処理中にCPU例外が発生した場合を除外すれば，呼び出してもか
まわない．全割込みロック状態かNMIの処理中に発生したCPU例外の場合には，
トレースログ取得処理を呼び出してはならない．

CPU例外ハンドラを実行する際に経由する部分では，CPU例外が起こる可能性を
極力減らすとともに，CPU例外を起こす可能性がある場合（例えば，スクラッチ
レジスタをスタックに保存する時に，バスエラーなどのCPU例外が発生する可能
性が考えられる）には，その可能性をターゲット依存部のユーザーズマニュア
ルに記載しなければならない．

ret_exc以降の処理は，割込みの出入口処理のret_int以降の処理と同じである
ため，ターゲットによっては，共通のルーチンを用いることができる可能性が
ある．

CPU例外の出入口処理をアセンブリ言語で記述する場合には，トレースログ取得
処理は，「6.2 トレースログ機能への対応」の節で記述した方法でコーディン
グすること．

6.6.2. CPU例外ハンドラの出入口処理の生成

CPU例外ベクトルをハードウェアで実現している場合など，CPU例外ハンドラ毎
に出入口処理を用意した方が効率が良いターゲットのために，CPU例外ハンドラ
毎に出入口処理を生成する機構を用意している．

以下のマクロは，標準のCPU例外管理機能の初期化処理を用いた場合のみ，ター
ゲット非依存部で使われる．CPU例外管理機能の初期化処理をターゲット依存部
で用意し，その中でこれらのマクロを使わない場合には，これらのマクロを用
意する必要はない．

(6-6-2-1) EXC_ENTRY(excno, exchdr)

CPU例外ハンドラ番号がexcno，CPU例外ハンドラの関数名がexchdrであるCPU例
外ハンドラの出入口処理のラベルを作るマクロ．EXCHDR_ENTRYを用いてCPU例外
ハンドラ毎に出入口処理を生成する場合には，次のように定義する．

#define EXC_ENTRY(excno, exchdr)	_kernel_##exchdr##_##excno

CPU例外ハンドラ毎に出入口処理を作る必要がない場合には，次のように定義し
て，CPU例外ハンドラの関数名をそのまま返す．

#define EXC_ENTRY(excno, exchdr)	exchdr

(6-6-2-2) EXCHDR_ENTRY(excno, excno_num, exchdr)

CPU例外ハンドラ番号がexcno，CPU例外ハンドラの関数名がexchdrであるCPU例
外ハンドラの出入口処理を生成するマクロ．excno_numには，アセンブリ言語記
述用に，CPU例外ハンドラ番号が数値で渡される．CPU例外ハンドラ毎に出入口
処理を作る必要がない場合には，空に定義する．

6.6.3. CPU例外ハンドラの設定

(6-6-3-1) bool_t VALID_EXCNO_DEFEXC(EXCNO excno)（オプション）

excnoが，DEF_EXCに対するCPU例外ハンドラ番号として有効な値である場合に
true，そうでない場合にfalseを返すマクロ．

SSPカーネルのターゲット非依存部では，このマクロは使われていないため，ター
ゲット依存部で使わないなら，用意する必要がない．

(6-6-3-2) void x_define_exc(EXCNO excno, FP exc_entry)

excnoで指定されたCPU例外ハンドラの出入口処理の番地をexc_entryに設定する．

この関数は，標準のCPU例外管理機能の初期化処理を用いた場合のみ，ターゲッ
ト非依存部から呼び出される．CPU例外管理機能の初期化処理をターゲット依存
部で用意し，その中でこの関数を呼び出さない場合には，この関数を用意する
必要はない．

この関数は，ターゲット非依存部のカーネル初期化処理から呼び出されるため，
カーネルの初期化処理（NMIを除くすべての割込みがマスクされている）から呼
び出せるように実装すればよい．

指定されたCPU例外ハンドラ番号がDEF_EXCに対するものとして有効な値でない
場合の動作は保証する必要がない（assertでエラーとするのが望ましい）．こ
れは，コンフィギュレータが，パス2のテンプレートファイルのターゲット依存
部で定義するEXCNO_DEFEXC_VALIDを用いてエラーを検出するためである．

6.6.4. CPU例外管理機能の初期化処理の変更

(6-6-4-1) OMIT_INITIALIZE_EXCEPTION（オプション）

CPU例外管理機能の初期化処理をターゲット依存部で用意し，ターゲット非依存
部に含まれる標準の割込み管理機能の初期化処理を用いない場合には，このシ
ンボルをマクロ定義する．

このシンボルをマクロ定義すると，EXCINIBとinitialize_exceptionの定義が，
カーネルのターゲット非依存部から取り除かれる．また，TNUM_EXCNO，
tnum_excno，excinib_tableの定義と，CPU例外ハンドラ毎の出入口処理を生成
するための記述（EXCHDR_ENTRYマクロのリスト）を，コンフィギュレータのパ
ス2のテンプレートファイルのターゲット非依存部によってkernel_cfg.cに生成
されなくなる．

(6-6-4-2) void initialize_exception(void)（オプション）

OMIT_INITIALIZE_EXCEPTIONをマクロ定義した場合には，この関数をターゲット
依存部で用意する．OMIT_INITIALIZE_EXCEPTIONをマクロ定義することにより取
り除かれるその他のデータ型，変数，マクロは，この関数で使用する場合にの
み用意すればよい．

6.6.5. デフォルトのCPU例外ハンドラ

(6-6-5-1) default_exc_handler(void)（オプション）

コンフィギュレータによりCPU例外ハンドラのテーブルを生成する場合などには，
CPU例外ハンドラを登録しなかったCPU例外ハンドラ番号に対して，デフォルト
のCPU例外ハンドラとして，default_exc_handlerを登録する．

default_exc_handlerは，標準のものをターゲット依存部で用意するが，ユーザ
が用意したもので置き換えられるように，OMIT_DEFAULT_EXC_HANDLERをマクロ
定義した場合には，ターゲット依存部で定義しないようにする．なお，ユーザ
が用意する場合の名称は，_kernel_default_exc_handlerとなる．

6.7. カーネルの起動・終了とスタック領域など

(6-7-1) スタートアップモジュール

カーネルのスタートアップモジュールは，システムのリセット後に最初に実行
されるプログラムである．スタートアップモジュールは，標準的には，プロセッ
サ依存部またはチップ依存部で用意し以下の処理を行うが，それにこだわる必
要はない．具体的には，開発環境に用意されているスタートアップモジュール
を用いる方法（この場合，ターゲット依存部でmain関数を用意する必要がある）
や，アプリケーションで用意する場合が考えられる．

(a) プロセッサ状態の初期化

プロセッサモード，スタックポインタ，フレームポインタ等，プロセッサの状
態を初期化する．また，NMIを除くすべての割込みをマスクした状態（全割込み
ロック状態と同等の状態）とする．DRAMコントローラの初期化など，メモリを
アクセスするために必要な初期化処理をここで行ってもよい（次の
hardware_init_hookで行ってもよい）．

(b) hardware_init_hookを呼び出す

システムのリセット後すぐに行う必要のあるターゲットシステム依存の初期化
処理を行うために，hardware_init_hookを呼び出す．hardware_init_hookが用
意されていない場合は，何もしない．GNU開発環境では，リンカスクリプト中の
weak definitionにより，hardware_init_hookが用意されていない場合の値を0
とすることで，これを実現できる．weak definitionの機能を持たない開発環境
では，hardware_init_hookを必ず呼び出すことにする．

hardware_init_hookは，ターゲット依存部で用意するのが標準であるが，シス
テムのリセット後すぐに行う必要のある初期化処理を追加するために，アプリ
ケーションで用意したものを用いる場合もある．

メモリアクセスに必要な初期化処理をhardware_init_hookで行う場合には，こ
れを呼び出す時点でメモリにアクセスすることができないため，関数（サブルー
チン）を呼び出すためにスタックを使用するプロセッサでは，戻り番地を汎用
レジスタに入れて呼び出すといった工夫が必要である．この場合，
hardware_init_hookをC言語で記述することはできなくなるが，やむをえない．

(c) bssセクションとdataセクションの初期化

bssセクションをクリアし，dataセクションに初期値を設定する．

ただし，カーネル本体は，kerflgがfalse（＝0）に初期化されること以外に，
これらのセクションが初期化されることに依存していないため，スタートアッ
プモジュールをアプリケーションで用意する場合で，システムサービスやアプ
リケーションがこれらのセクションが初期化されることに依存していない場合
には，システムの起動時間を短縮するために，kerflgをfalseに初期化するだけ
で十分である．

(d) software_init_hookを呼び出す

開発環境（特にライブラリ）に依存して必要な初期化処理を行うために，
software_init_hookを呼び出す．software_init_hookが用意されていない場合
は，何もしない．GNU開発環境では，リンカスクリプト中のweak definitionに
より，software_init_hookが用意されていない場合の値を0とすることで，これ
を実現できる．weak definitionの機能を持たない開発環境では，
software_init_hookを必ず呼び出すことにする．

software_init_hookは，ターゲット依存部で用意するのが標準である．

(e) sta_kerへ分岐

sta_kerを呼び出す．sta_kerは，NMIを除くすべての割込みをマスクした状態
（全割込みロック状態と同等の状態）で呼び出さなければならない．sta_kerか
らはリターンすることがないため，スタートアップモジュールに戻ってくるこ
とは考える必要がない．

(6-7-2) void target_initialize(void)

ターゲット依存部の初期化を行う関数．sta_kerの最初で呼び出される．プロセッ
サ・チップ・開発環境依存の初期化処理を，それらの依存部に切り分けること
も可能である．

この関数は，あくまでもカーネルのターゲット依存部の初期化処理を行うため
のものである．アプリケーションに必要な初期化処理は，初期化ルーチンで行
うのが基本であるが，システムのリセット後すぐに行う必要がある場合には，
hardware_init_hookを用いる．

(6-7-3) void call_exit_kernel(void)

非タスクコンテキストに切り換えて，exit_kernelへ分岐する関数．ext_kerか
ら呼び出される．exit_kernelからはリターンすることがないため，この関数に
戻ってくることは考える必要がない．

非タスクコンテキストに切り換えるのは，終了処理ルーチンを，非タスクコン
テキスト用のスタックで実行するためである．終了処理ルーチンをタスク用の
スタックで実行すると，各タスクのスタック領域のサイズを決定する際に，終
了処理ルーチンが使用するスタック領域を考慮しなければならない．これには，
終了処理ルーチンが使用するスタック領域が大きい場合に各タスクのスタック
領域を無駄に大きくしなければならないことに加えて，意図しないスタックオー
バーフローが発生する可能性を高めるという問題がある．

この関数は，全割込みロック状態で呼ばれるため，全割込みロック状態から呼
び出すことができない関数を呼ばないように実装しなければならない．

(6-7-4) void target_exit(void)

ターゲット依存部の終了処理を行う関数．この関数は，カーネル終了処理の最
後に呼び出され，リターンしてはならない．プロセッサ・チップ・開発環境依
存の終了処理を，それらの依存部に切り分けることも可能である．

この関数では，最初に，atexitによって登録された関数とデストラクタを呼び
出すことを意図しており，標準的には，software_term_hookを呼び出す．
software_term_hookが用意されていない場合は，何もしない．GNU開発環境では，
リンカスクリプト中のweak definitionにより，software_term_hookが用意され
ていない場合の値を0とすることで，これを実現できる．weak definitionの機
能を持たない開発環境では，software_term_hookを必ず呼び出すことにする．

この関数は，全割込みロック状態で呼ばれるため，全割込みロック状態から呼
び出すことができない関数を呼ばないように実装しなければならない．

6.8. カーネル内部のチューニング

6.8.1. ビットマップサーチ

(6-8-1-1) OMIT_BITMAP_SEARCH（オプション）
(6-8-1-2) uint_t bitmap_search(uint16_t bitmap)（オプション）

ターゲット非依存部で，uint16_t型の整数値（bitmap）中の1のビットの内，最
も下位（右）のものをサーチし，そのビット番号を返す関数bitmap_searchを用
意している．ここで，ビット番号は最下位ビットを0とし，bitmapに0を指定し
てはならないものとしている．

ビットサーチ命令を持つプロセッサでは，bitmap_searchを，ビットサーチ命令
を使うように書き直した方が効率が良い場合がある．このような場合には，ター
ゲット依存部でビットサーチ命令を使ったbitmap_searchを定義し，
OMIT_BITMAP_SEARCHをマクロ定義する．

標準ライブラリにビットサーチ命令を用いたffsがある場合，bitmap_searchを
(ffs(bitmap) - 1)に定義するとよい．

(6-8-1-3) uint16_t PRIMAP_BIT(PRI pri)（オプション）

ビットサーチ命令のサーチ方向が逆などの理由で，優先度とビットとの対応を
変更したい場合には，PRIMAP_BITをマクロ定義する．

6.9. カーネル実装に関するその他の定義

6.9.1. 非タスクコンテキスト用のスタック領域

(6-9-1-1)  DEFAULT_ISTKSZ

DEF_ICSにより非タスクコンテキスト用のスタック領域が指定されない場合の，
デフォルトのスタック領域のサイズ．

※
(6-9-1-2)  DEFAULT_ISTK（オプション）

DEF_ICSにより非タスクコンテキスト用のスタック領域が指定されない場合の，
デフォルトのスタック領域の先頭番地．このマクロが定義されない場合には，
サイズがDEFAULT_ISTKSZのスタック領域が，配列により確保される．

(6-9-1-3) STK_T *TOPPERS_ISTKPT(STK_T *istk, SIZE istksz)（オプション）

非タスクコンテキスト用のスタックポインタの初期値を保持する変数（istkpt）
を用いる場合に，このシンボルに，スタック領域の先頭番地（istk）とスタッ
ク領域のサイズ（istksz）から，スタックポインタの初期値を求めるマクロを
定義する．

6.9.2. 空ラベルの定義

(6-9-2-1) TOPPERS_EMPTY_LABEL(type, symbol)（オプション）

リンクエラーを防ぐために，データ型typeの配列である変数symbolに定義を与
えるためのマクロ．与えた定義が参照されることはないため，どのような定義
を与えてもよい．

デフォルトでは，symbolを，要素型がtypeでサイズが0の配列に定義している．
サイズが0の配列がエラーとならないコンパイラ（GCCはこれに該当）を用いる
場合には，ターゲット依存部で定義する必要はない．

6.10. トレースログ機能に関する設定

SSPカーネルのソースコードには，カーネルの実行トレースログを取得するため
のマクロ等が埋め込んである．デフォルトでは，これらのマクロは空に定義さ
れてトレースログの取得は行わないが，これらのマクロを適切に定義すること
でトレースログの取得を行うことができる．

6.10.1. 取得できるトレースログの種類とマクロ

取得できるトレースログの種類と，それを取得するために定義するマクロは次
の通りである．

(a) カーネルの動作開始と終了

次のマクロを定義することで，カーネルの動作開始時と終了時のトレースログ
を取得することができる．

	LOG_KER_ENTER		カーネルが動作を開始する直前（初期化の完了後）
	LOG_KER_LEAVE		カーネルの終了（ext_ker）が呼ばれた直後（終了処
						理の実行前）

(b) 処理単位の実行開始と終了

次のマクロを定義することで，割込みハンドラ（INH），割込みサービスルーチ
ン（ISR），周期ハンドラ（CYC），アラームハンドラ（ALM），CPU例外ハンド
ラ（EXC），タスク例外処理ルーチン（TEX）の実行開始前と終了後のトレース
ログを取得することができる．

	LOG_<処理単位略号>_ENTER	処理単位の実行開始直前
	LOG_<処理単位略号>_LEAVE	処理単位の終了直後

割込みハンドラは，アプリケーションが登録したもののみを対象とし，割込み
サービスルーチンを呼び出すためにカーネル内に生成されるものは対象としな
い．タスクの実行開始と終了は，他の方法で取得できるため，この方法は用意
していない．

なお，割込みハンドラとCPU例外ハンドラの実行開始と終了のトレースログ取得
は，ターゲット依存部で実装する必要がある．詳しくは，「6.2 トレースログ
機能への対応」「6.6.1 割込みハンドラの出入口処理」「6.7.1 CPU例外ハンド
ラの出入口処理」の節を参照すること．

(c) タスク状態の変化

次のマクロを定義することで，タスク状態が変化した時のトレースログを取得
することができる．ただし，実行状態と実行可能状態の間の遷移は，他の方法
で取得できるため，このマクロでは取得できない．

	LOG_TSKSTAT		タスク状態の変化

(d) ディスパッチャの実行開始と終了

次のマクロを定義することで，ディスパッチャが実行開始する時と，終了する
時のトレースログを取得することができる．

	LOG_DSP_ENTER	ディスパッチャの実行開始
	LOG_DSP_LEAVE	ディスパッチャの終了

ディスパッチャの実行開始は，タスクが実行状態から実行可能状態に遷移する
タイミングであるため，実行可能状態へ遷移するタスクのTCBへのポインタをパ
ラメータとする．逆に，ディスパッチャの終了は，タスクが実行可能状態から
実行状態に遷移するタイミングであるため，実行状態へ遷移するタスクのTCBへ
のポインタをパラメータとする．

SSPカーネルでは，実行できるタスクがなく，カーネルがアイドル状態になる場
合には，ディスパッチャの中に留まる．そのため，アイドル状態への遷移とア
イドル状態から他の状態への遷移は，このマクロでは取得できない．

なお，ディスパッチャの実行開始と終了のトレースログ取得は，ターゲット依
存部で実装する必要がある．詳しくは，と「6.4.2 ディスパッチャ本体」の節を
参照すること．

(e) サービスコールの入口と出口

次のマクロを定義することで，各サービスコールの入口と出口のトレースログ
を取得することができる．

	LOG_<サービスコールの大文字表記>_ENTER		サービスコール名の入口
	LOG_<サービスコールの大文字表記>_LEAVE		サービスコール名の出口

それぞれのマクロの名称やパラメータの詳細については，カーネルのソースコー
ドを参照すること．

6.11. カーネル実装のターゲット依存部のためのリネーム記述

カーネル内部に閉じて使われる関数や変数などの名称で，オブジェクトファイ
ルのシンボル表に登録されて外部から参照できる名称は，C言語レベルで，先頭
が"_kernel_"または"_KERNEL_"である名称としなければならないが，SSPカーネ
ルでは，ソースコードをコンパクトに保ちつつこれを実現するために，リネー
ム記述ファイルを導入している．

具体的には，リネームすべき名称をリストアップしたxxx_rename.defを用意し，
このファイルからツール（utils/genrename）により，名称をリネームするため
のマクロ定義を含むxxx_rename.hと，それらのマクロ定義を解除するための
xxx_unrename.hを生成する．ツールの起動方法は次の通りである．

	% genrename xxx

xxx_rename.defには，リネームすべき名称を1行に1つ記述する．xxxxという名
称が記述されている場合，xxx_rename.hには次のような記述が生成される．

#define xxxx				_kernel_xxxx
#ifdef TOPPERS_LABEL_ASM
#define _xxxx				__kernel_xxxx
#endif /* TOPPERS_LABEL_ASM */

また，xxx_unrename.hには次のような記述が生成される．

#undef xxxx
#ifdef TOPPERS_LABEL_ASM
#undef _xxxx
#endif /* TOPPERS_LABEL_ASM */

xxx_rename.defの中には，他のリネーム記述を取り込むために，「INCLUDE
"yyy"」または「INCLUDE <yyy>」という記述を含めることができる．この記述
がされている場合，xxx_rename.hには「#include "yyy_rename.h"」または
「#include <yyy_rename.h>」という記述が，xxx_unrename.hには「#include
"yyy_unrename.h"」または「#include <yyy_unrename.h>」という記述が生成さ
れる．

xxx_rename.defの中の"#"で始まる行はコメントとして読み飛ばされる．また，
空行も無視される．

カーネルのターゲット非依存部で使われる名称をリネームするために，kernel
ディレクトリに，kernel_rename.defと，そこから生成したkernel_rename.hお
よびkernel_unrename.hが用意されている．kernel_rename.defには，
「INCLUDE "target"」という記述が含まれており，ターゲット依存部のリネー
ム記述を取り込むようになっている．ターゲット依存部で定義し，ターゲット
非依存部で参照される名称は，ターゲット依存部のリネーム記述に含める．

ターゲット依存部では，ターゲット依存部で使われる名称をリネームするため
に，target_rename.defと，そこから生成したtarget_rename.hおよび
target_unrename.hを用意する．ターゲット依存部からプロセッサ・チップ・開
発環境依存部を切り分ける場合には，target_rename.defにINCLUDE記述を入れ，
プロセッサ・チップ・開発環境依存部のリネーム記述を取り込むようにする．

6.12. タイマドライバ

タイマドライバは，カーネルにタイムティックを通知するためのタイマドライ
バである．

6.12.1. タイマドライバのファイル構成

タイマドライバを組み込むための静的APIを記述したシステムコンフィギュレー
ションファイルを，target_timer.cfgに用意する．このファイルには，タイマ
ドライバを初期化するための初期化ルーチンの追加，タイマドライバを終了さ
せるための終了処理ルーチンの追加，タイマ割込みのための割込みハンドラの
定義（または，割込みサービスルーチンの追加），タイマ割込みのための割込
み要求ラインの属性の設定の静的APIなどを含むことになる．

タイマドライバを呼び出すために必要な定義を含むヘッダファイルを，
target_timer.hに用意する．また，タイマドライバの実装ファイルを
target_timer.cに用意する．

タイムティックの通知により行う処理の多くは，タスクの起動や待ち解除を行
うものであるため，タイマ割込みの割込み優先度は，割込みの中で最低の優先
度で十分である．ただし，周期ハンドラやアラームハンドラの実行開始遅れが
問題になる場合には，タイマ割込みの割込み優先度をより高い値に設定したい．
そこで，タイマ割込みの割込み優先度を変更する方法を，ターゲット依存部の
ユーザーズマニュアルに記載すべきである．

6.12.2. タイマの初期化・終了処理・割込み処理

(6-12-2-1) void target_timer_initialize(intptr_t exinf)

タイマを初期化し，タイマ割込みを周期的に発生させる関数．タイマ割込みの
周期は，TIC_NUMEとTIC_DENOで指定された時間と一致させる（「5.2 タイム
ティックの定義」の節を参照）．

この関数は，target_timer.cfg中に記述する静的APIにより，初期化ルーチンと
してカーネルに登録することを想定している．

(6-12-2-2) void target_timer_terminate(intptr_t exinf)

タイマの動作を停止させ，タイマ割込みを発生しないようにする関数．

この関数は，target_timer.cfg中に記述する静的APIにより，終了処理ルーチン
としてカーネルに登録することを想定している．

(6-12-2-3) void target_timer_handler(void)
    または void target_timer_isr(intptr_t exinf)

タイマ割込みにより起動される割込み処理プログラム．割込みハンドラとして
実現する場合にはtarget_timer_handler，割込みサービスルーチンとして実現
する場合にはtarget_timer_isrの名称とする．ターゲット非依存部の
signal_timeを呼び出す．

target_timer_handlerは，標準的には次のように定義する．

----------------------------------------
void
target_timer_handler(void)
{
	i_begin_int(<タイマ割込みの割込み番号>);
	signal_time();
	i_end_int(<タイマ割込みの割込み番号>);
}
----------------------------------------

この関数は，target_timer.cfg中に記述する静的APIにより，割込みハンドラま
たは割込みサービスルーチンとしてカーネルに登録することを想定している．

6.12.3. 性能評価用システム時刻の参照のための機能

性能評価用システム時刻の参照機能（get_utm）をサポートする場合には，タイ
マドライバで，以下のデータ型や関数などを用意する．

(6-12-3-1) CLOCK

タイマ値の内部表現のためのデータ型．

(6-12-3-2) CLOCK target_timer_get_current(void)

タイマの現在値を読み出し，内部表現で返す関数．タイマ値は，時間の経過と
ともに増加することを想定している．ハードウェアのタイマが，タイマ値が減
少するものである場合には，この関数内で増加する値となるように変換する．

(6-12-3-3) bool_t target_timer_probe_int(void)

タイマ割込み要求をチェックする関数．タイマ割込みが要求されている場合に
true，要求されていない場合にfalseを返す．

(6-12-3-4) TO_USEC(clock)

タイマ値の内部表現を，1μ秒単位に変換するためのマクロ（または関数）．
targettimer_get_currentで読み出した値を，タイマ割込み発生からの経過時間
（単位: 1μ秒）に変換するために用いる．

７．コンフィギュレータ設定ファイルのターゲット依存部

7.1. 設定ファイルとターゲット依存部の位置付け

SSPカーネルのコンフィギュレータは，設定ファイルの記述に従ってファイルの
生成およびエラーチェックを行う．コンフィギュレータの設定ファイルには，
以下の4つがある．

(a) 静的APIテーブル

静的APIの一覧と，各静的APIのパラメータについて記述したファイル．静的
APIを拡張する場合以外は変更する必要がないため，ターゲット非依存部で用意
している（kernel/kernel_api.csv）．

(b) 値取得シンボルテーブル

コンフィギュレータのパス1において，パラメータ計算用C言語ファイルに出力
し，値を求めたいシンボル（一般には式）を記述するためのファイル．ターゲッ
ト非依存部では，ターゲットに依存せずに必要となるシンボルを記述したファ
イルを用意している（kernel/kernel_def.csv）．

ターゲットに依存して必要となるシンボルがある場合には，targetディレクト
リに置かれたtarget_def.csv中に記述する．target_def.csv中に記述して値を
求めることができるシンボルは，kernel/kernel_int.hおよびそこからインクルー
ドされるファイルで定義されていなければならない．kernel_int.hからは，
target_stddef.h，target_kernel.h，target_config.hを（間接的に）インクルー
ドしているため，これらのファイルおよびそこからインクルードされるファイ
ルで定義されるターゲット依存のシンボルは，target_def.csv中に記述するこ
とができる．

ここで値を求めたシンボルの値は，コンフィギュレータのパス2およびパス3の
テンプレートファイル中で参照することができる．

(c) パス2のテンプレートファイル

コンフィギュレータのパス2は，テンプレートファイルに従って，カーネルの構
成・初期化ファイル（kernel_cfg.c），構成・初期化ヘッダファイル
（kernel_cfg.h）などを生成する．このテンプレートファイルは，ターゲット
非依存部とターゲット依存部に切り分けてあるが，他のファイルのターゲット
依存部とは逆に，ターゲット依存部からターゲット非依存部をインクルードす
る形になっている．

具体的には，targetディレクトリに置かれたtarget.tfで，必要な変数を定義し
た後，テンプレートファイルのターゲット非依存部（kernel/kernel.tf）をイ
ンクルードする．kernel.tfでは，カーネルのターゲット非依存部で使用する変
数定義等を生成する．kernel.tfをインクルードした後，target.tfでは，カー
ネルのターゲット依存部で使用する変数定義等を生成する．target.tfから，プ
ロセッサ依存部，チップ依存部を，開発環境依存部を切り分けてもよい．

(d) パス3のテンプレートファイル

コンフィギュレータのパス3は，テンプレートファイルに従って，静的APIの一
般定数式パラメータのチェックを行う．このテンプレートファイルも，ターゲッ
ト非依存部とターゲット依存部に切り分けてあり，ターゲット依存部からター
ゲット非依存部をインクルードする形になっている．

具体的には，targetディレクトリに置かれたtarget_check.tfで，必要な変数を
定義した後，テンプレートファイルのターゲット非依存部
（kernel/kernel_check.tf）をインクルードする．kernel_check.tfでは，カー
ネルのターゲット非依存部で初期化ブロックに出力した一般定数式パラメータ
のチェックを行う．kernel_check.tfをインクルードした後，target_check.tf
では，ターゲットに依存するチェックを行う．target_check.tfから，プロセッ
サ依存部，チップ依存部を，開発環境依存部を切り分けてもよい．

なお，コンフィギュレータの詳細仕様と設定ファイルの記述方法については，
別途PDFファイルの形で配布している「TOPPERS新世代カーネル用コンフィギュ
レータ仕様」および「TOPPERS新世代カーネル用コンフィギュレータ内蔵マクロ
プロセッサ仕様」を参照すること．

7.2. パス2のテンプレートファイルのターゲット依存部

以下では，パス2のテンプレートファイルのターゲット依存部を記述する上で必
要な事項について説明する．

7.2.1. ターゲット非依存部をインクルードする前に定義すべき変数

target.tfからkernel.tfをインクルードする前に，次の変数を定義しておかな
ければならない．

(7-2-2) INTNO_ATTISR_VALID		ATT_ISRで使用できる割込み番号
(7-2-3) INHNO_ATTISR_VALID		INTNO_ATTISR_VALIDに対応する割込ハンドラ番号
(7-2-4) INHNO_DEFINH_VALID		DEF_INTで使用できる割込みハンドラ番号
(7-2-5) EXCNO_DEFEXC_VALID		DEF_EXCで使用できるCPU例外ハンドラ番号
(7-2-6) INTNO_CFGINT_VALID		CFG_INTで使用できる割込み番号
(7-2-7) INTPRI_CFGINT_VALID		CFG_INTで使用できる割込み優先度

APIで使用できる割込み番号／割込みハンドラ番号／CPU例外ハンドラ番号／割
込み優先度のリストを，各変数に定義する．INHNO_ATTISR_VALIDには，
INTNO_ATTISR_VALIDにリストアップした割込み番号に対応する割込みハンドラ
番号のリストを定義する．

(7-2-8) TARGET_TSKATR（オプション）		ターゲット定義のタスク属性
(7-2-9) TARGET_ISRATR（オプション）		ターゲット定義のISR属性
(7-2-10) TARGET_INHATR（オプション）		ターゲット定義の割込みハンドラ属性
(7-2-10) TARGET_INTATR（オプション）	ターゲット定義の割込み属性
(7-2-11) TARGET_EXCATR（オプション）	ターゲット定義のCPU例外ハンドラ属性

各オブジェクトの属性を，ターゲット定義に拡張する場合に，該当するオブジェ
クト属性を示す変数に，拡張に使用するビットの論理和を定義する．これによ
り，拡張に使用するビットが設定されている場合に，エラーになるのを防ぐ．

(7-2-12) INTNO_FIX_KERNEL（オプション）		カーネル管理に固定されている
											割込み番号
(7-2-13) INHNO_FIX_KERNEL（オプション）		カーネル管理に固定されている
		 									割込みハンドラ番号
(7-2-14) INHNO_FIX_NONKERNEL（オプション）	カーネル管理外に固定されている
											割込み番号
(7-2-15) INHNO_FIX_NONKERNEL（オプション）	カーネル管理外に固定されている
		 									割込みハンドラ番号

カーネル管理またはカーネル管理外に固定されている割込みがある場合には，
それらの割込み番号と割込みハンドラ番号のリストを，各変数に定義する．

(7-2-16) USE_INHINIB_TABLE（オプション）

OMIT_INITIALIZE_INTERRUPTを定義したが，割込みハンドラの初期化に必要な情
報をkernel_cfg.cに生成したい場合には，この変数を1に設定する．具体的には，
TNUM_INHNO，tnum_inhno，inhinib_tableの定義と，割込みハンドラ毎の出入口
処理を生成するための記述（INTHDR_ENTRYマクロのリスト）が，ターゲット非
依存部によって生成される．

(7-2-17) USE_INTINIB_TABLE（オプション）

OMIT_INITIALIZE_INTERRUPTを定義したが，割込み要求ラインの初期化に必要な
情報をkernel_cfg.cに生成したい場合には，この変数を1に設定する．具体的に
は，TNUM_INTNO，tnum_intno，intinib_tableの定義が，ターゲット非依存部に
よって生成される．

(7-2-18) TARGET_MIN_STKSZ（オプション）

ターゲット定義で，タスクのスタックサイズの最小値を設定する場合には，こ
の変数をスタックサイズの最小値に定義する．

(7-2-19) CHECK_STKSZ_ALIGN（オプション）

スタック領域のサイズがある値の倍数でなければならない場合に，この変数を
その値に定義する．この変数を定義することで，kernel.tfにおいて，スタック
領域のサイズが正しくない（この変数に定義した値の倍数でない）場合のエラー
をチェックするようになる．チェックが必要ない場合には，この変数を定義し
ない．

7.2.2. ターゲット非依存部で定義される変数

kernel.tfの中では次の変数が定義されるため，kernel.tfをインクルードした
後，target.tfの中でこれらを参照することができる．

(7-2-12) INTNO[inhno]		inhnoを対応するintnoに変換するための連想配列
(7-2-13) INHNO[intno]		intnoを対応するinhnoに変換するための連想配列

7.3. パス3のテンプレートファイルのターゲット依存部

以下では，パス3のテンプレートファイルのターゲット依存部を記述する上で必
要な事項について説明する．

target_check.tfからkernel_check.tfをインクルードする前に，必要に応じて，
次の変数を定義しておかなければならない．

(7-3-1) CHECK_FUNC_ALIGN（オプション）　関数のアライン単位
(7-3-2) CHECK_FUNC_NONNULL（オプション）関数の非NULLチェック
(7-3-3) CHECK_STACK_ALIGN（オプション）	スタック領域のアライン単位
(7-3-4) CHECK_STACK_NONNULL（オプション）スタック領域の非NULLチェック
(7-3-5) CHECK_MPF_ALIGN（オプション）	固定長メモリプール領域のアライン単位
(7-3-6) CHECK_MPF_NONNULL（オプション）	固定長メモリプール領域の非NULLチェック

関数／スタック領域／固定長メモリプール領域の先頭番地のアラインメントの
チェックを行う場合には，それぞれ，CHECK_FUNC_ALIGN／CHECK_STACK_ALIGN／
CHECK_MPF_ALIGNをアライン単位に定義する．関数／スタック領域／固定長メモ
リプール領域の先頭番地がNULLでないかのチェックを行う場合には，それぞれ
CHECK_FUNC_NONNULL／CHECK_STACK_NONNULL／CHECK_MPF_NONNULLを1に定義する．
チェックが必要ない場合には，該当する変数を定義しない．

7.4. cfg1_out.cのリンクに必要なスタブの定義ファイル

コンフィギュレータに関してターゲット依存に用意する必要があるファイルと
して，設定ファイル以外に，cfg1_out.cをリンクするために必要なスタブの定
義ファイルがある．

コンフィギュレータのパス1では，静的APIの整数定数式パラメータの値をCコン
パイラを用いて求めるために，cfg1_out.cを生成する．これをコンパイル，リ
ンクしてオブジェクトファイルを生成する際に，スタートアップモジュールか
ら参照されるシンボルの定義を与える必要がある．

この定義を与えるために，cfg1_out.cから，ターゲット依存部の
target_cfg1_out.hをインクルードしている．target_cfg1_out.h（または，そ
こからインクルードされるファイル）には，スタートアップモジュールから参
照されるシンボルのスタブの定義を含める．典型的には，以下のような定義を
含める必要がある．

----------------------------------------
void sta_ker(void)
{
}

void hardware_init_hook(void)
{
}

void software_init_hook(void)
{
}

const SIZE		_kernel_istksz = 0;

STK_T *const	_kernel_istk = NULL;
----------------------------------------


８．システムサービス等のターゲット依存部

8.1. システムサービスのターゲット依存部

シリアルポート数やシステムログタスク関連の定数など，システムサービスの
構成を決定するための定義をtarget_syssvc.hまたはそこからインクルードされ
るファイル（プロセッサ・チップ・開発環境依存部で用意されるヘッダファイ
ルなど）に含める．

なお，TOPPERS組込みコンポーネントシステムが導入されると，このファイルの
内容はコンポーネント記述ファイルに記述されることになり，このファイルは
無くなる（または，大幅に縮小される）見込みである．

8.2. シリアルインタフェースドライバのターゲット依存部

ターゲット依存部で提供すべきシリアルインタフェースドライバのための定義
は次の通りである．これらの定義は，別に指定がない限り，target_serial.hま
たはそこからインクルードされるファイルに含め，必要なコンフィギュレーショ
ン情報をtarget_serial.cfgに記述する．関数の実体が必要な場合には，
target_serial.c等のファイルを用意する．

シリアルインタフェースドライバの中で，ターゲットのシリアルI/Oデバイスに
依存する部分を，シリアルI/Oデバイスドライバと呼ぶ．シリアルI/Oデバイス
ドライバは，おおよそ，ITRONデバイスドライバ設計ガイドラインのPDICに相当
する．PDICに相当するファイルで，他のシステムにも共通に使える可能性があ
る場合には，pdicディレクトリに置く．

8.2.1. 変数，データ型，管理関数

(8-2-1-1) TNUM_PORT

シリアルインタフェースドライバがサポートするシリアルポート数を定義する
マクロ．このマクロの定義は，target_syssvc.hまたはそこからインクルードさ
れるファイルに含める．

(8-2-1-2) void sio_initialize(intptr_t exinf)（オプション）

シリアルI/Oデバイスドライバの初期化処理．target_serial.cfgに，この関数
を初期化ルーチンとして登録する静的APIを含める．

(8-2-1-3) void sio_terminate(intptr_t exinf)（オプション）

シリアルI/Oデバイスドライバの終了処理．target_serial.cfgに，この関数を
終了処理ルーチンとして登録する静的APIを含める．

(8-2-1-4) void sio_isr(intptr_t exinf)

シリアルI/Oデバイスの割込みサービスルーチン．target_serial.cfgに，この
関数を割込みサービスルーチンとして登録する静的APIを含める．また，その静
的APIに必要なシリアルI/Oデバイスの割込み番号などは，target_serial.hでマ
クロ定義する．割込みサービスルーチンではなく，割込みハンドラとすること
もできる．

(8-2-1-5) SIOPCB

シリアルI/Oポート管理ブロックのデータ型（target_serial.hには，データ型
の宣言だけ含まれていればよい）．

(8-2-1-6) SIO_RDY_SNDとSIO_RDY_RCV

送信可能コールバックの識別番号をSIO_RDY_SNDに，受信通知コールバックの識
別番号をSIO_RDY_RCVにマクロ定義する．コールバックの禁止／許可を行なうサー
ビスコール（sio_ena_cbrとsio_dis_cbr）で用いる．

8.2.2. デバイスサービスルーチン

以下のデバイスサービルルーチンは，（少なくとも）シリアルI/Oポートからの
割込みがマスクされた状態で呼び出される．また，タスクコンテキスト，非タ
スクコンテキストのいずれで呼び出される場合もある（いずれで呼び出されて
も動作するようにしなければならない）．

(8-2-2-1) SIOPCB *sio_opn_por(ID siopid, intptr_t exinf)

siopidで指定されるシリアルI/Oポートをオープンする関数．exinfはシリアル
I/Oポートに対する拡張情報で，コールバックを呼ぶ時にポートを区別するた
めに渡す．

(8-2-2-2) void sio_cls_por(SIOPCB *siopcb)

siopcbで指定されるシリアルI/Oポートをクローズする関数．

(8-2-2-3) bool_t sio_snd_chr(SIOPCB *siopcb, char_t c)

siopcbで指定されるシリアルI/Oポートに，cで示される文字を送信する関数．
文字を送信レジスタに入れた場合にはtrueを，前に送信した文字の送信が終わっ
ていないために，文字を送信レジスタに入れられなかった場合にはfalseを返す．

(8-2-2-4) int_t sio_rcv_chr(SIOPCB *siopcb)

siopcbで指定されるシリアルI/Oポートから文字を読む関数．文字を受信してい
た場合，読んだ文字のコードは正の値として返し，文字を受信していない場合
には-1を返す．

(8-2-2-5) void sio_ena_cbr(SIOPCB *siopcb, uint_t cbrtn)

siopcbで指定されるシリアルI/Oポートからの，cbrtnで指定されるコールバッ
クを許可する．cbrtnには，SIO_RDY_SNDかSIO_RDY_RCVを指定できる．

(8-2-2-6) void sio_dis_cbr(SIOPCB *siopcb, uint_t cbrtn)

siopcbで指定されるシリアルI/Oポートからの，cbrtnで指定されるコールバッ
クを禁止する．cbrtnには，SIO_RDY_SNDかSIO_RDY_RCVを指定できる．

8.2.3. コールバックルーチン

ターゲット依存部は，必要なタイミングで，シリアルインタフェースドライバ
のターゲット非依存部に含まれる以下のコールバックルーチンを呼び出びださ
なければならない．ただし，それぞれのコールバックが禁止されている時は，
コールバックルーチンを呼び出してはならない．

コールバックルーチンは，（少なくとも）シリアルI/Oポートからの割込みが禁
止された状態で，非タスクコンテキストで呼び出す．exinfには，シリアルI/O
ポートのオープン時に指定された拡張情報を渡す．

(8-2-3-1) void sio_irdy_snd(intptr_t exinf)

送信可能コールバックルーチン．シリアルI/Oポートに対して文字が送信できる
状態になった場合に呼び出す．シリアルインタフェースドライバは，このコー
ルバックルーチンの中で，sio_snd_chrを呼び出して次の文字を送信するか，送
信すべき文字がない場合には送信可能コールバックを禁止する．

(8-2-3-2) void sio_irdy_rcv(intptr_t exinf)

受信通知コールバックルーチン．シリアルI/Oポートから文字を受信した場合に
呼び出す．シリアルインタフェースドライバは，このコールバックルーチンの
中で，必ずsio_rcv_chrを呼び出して受信した文字を取り出す．

8.3. カーネル起動メッセージの出力のターゲット依存定義

ターゲット依存部で提供すべきカーネル起動メッセージの出力のための定義は
次の通りである．

(8-3-1) TARGET_NAME

ターゲットの名称に定義する．

(8-3-2) TARGET_COPYRIGHT（オプション）

カーネル起動メッセージに，ターゲット依存部の著作権表示を追加するための
マクロ．デフォルトでは，ターゲット依存部の著作権表示を追加しない．

8.4. サンプルプログラムとテストプログラムのターゲット依存定義

ターゲット依存部で提供すべきサンプルプログラムおよびテストプログラムの
ための定義は次の通りである．これらの定義は，target_test.h（またはそれら
からインクルードされるファイル）に含める．

(8-4-1) STACK_SIZE（オプション）

サンプルプログラムおよびテストプログラムのタスクのスタックサイズを定義
するマクロ．定義しない場合のデフォルト値は4096．デフォルト設定ではメモ
リが不足する場合や，シミュレーション環境などで大きいスタック領域が必要
な場合には，ターゲット依存部でこのマクロを設定するスタックサイズに定義
する．

(8-4-2) CPUEXC1（オプション）

サンプルプログラムおよびテストプログラムで用いるCPU例外のCPU例外ハンド
ラ番号を定義するマクロ．このマクロを定義しない場合，CPU例外ハンドラを使
う部分がサンプルプログラムから除外される．CPU例外ハンドラのテストをする
テストプログラムはコンパイルできない．

(8-4-3) RAISE_CPU_EXCEPTION（オプション）

CPUEXC1に定義したCPU例外を発生させるC言語のプログラムを定義するマクロ．
CPUEXC1を定義した場合には必ず定義しなければならない．

(8-4-4) CANNOT_RETURN_CPUEXC（オプション）

ターゲットシステムの制約により，CPU例外ハンドラからリターンした後に，タ
スクの実行を継続できない場合に定義するマクロ．このマクロを定義すると，
CPU例外ハンドラのテストをするテストプログラムから，CPU例外ハンドラから
リターンした後の処理が除外される．サンプルプログラムの該当部分は正しく
動作しない．

(8-4-5) TASK_PORTID（オプション）

サンプルプログラムにおいて，コマンド文字を読み込むシリアルポート番号を
定義するマクロ．定義しない場合のデフォルト値は1．

(8-4-6) LOOP_REF（オプション）

サンプルプログラムにおいて，プロセッサの速度を計測するためのループ回数
を定義するマクロ．定義しない場合のデフォルト値は1000000．デフォルト設定
では，値が大き過ぎて計測に時間がかかりすぎる場合や，値が小さ過ぎて計測
結果が安定しない場合に，ターゲット依存部でこのマクロを設定するループ回
数に定義する．

(8-4-7) MEASURE_TWICE（オプション）

サンプルプログラムにおいて，プロセッサの速度を2度計測する場合に定義する
マクロ．シミュレーション環境などプロセッサの速度が変動する環境で，1度の
計測では計測結果が安定しない場合に定義する．

(8-4-8) TASK_LOOP（オプション）

サンプルプログラムにおいて，プロセッサの速度を計測せずに，タスク内での
ループ回数を固定する場合に，ループ回数を定義するマクロ．ループ全体の実
行時間が0.4秒程度になるようなループ回数を，このマクロに定義する．

９．その他

9.1. ドキュメント

ターゲット依存部のユーザーズマニュアルを，target_user.txtに用意する．プ
ロセッサ・チップ・開発環境依存部のユーザーズマニュアルを切り分けてもよ
いし，ファイルが大きくなる場合には複数のファイルに分割してよいが，その
場合には，target_user.txt中にそれらのファイル名を記述すること．

ターゲット依存部のユーザーズマニュアルには，少なくとも次のような内容を
記述することが望ましい．

(1) 対応しているターゲットシステムの種類・構成，バージョン番号
	・ターゲットハードウェア（ボード等）の名称と対応している構成
	・ターゲット略称
	・ターゲット非依存部のバージョン番号
	・プロセッサ，チップ，開発環境依存部の構成とバージョン番号
	・使用するPDICとバージョン番号

(2) 使用する開発環境と動作検証した条件（バージョン，オプション等）
	・言語処理系（コンパイラ，アセンブラ，リンカ等）
	・デバッグ環境

(3) ターゲット定義事項の規定

(3-1) データ型に関する規定
	・int_t型，long_t型のサイズ
	・char_t型，int_least8_t型，void *型，intptr_t型のサイズ
	・int8_t型，uint8_t型，int64_t型，uint64_t型，int128_t型，
	　uint128_t型，float32_t型，double64_t型のサポートの有無

(3-2) 割込み処理に関する規定
	・割込みハンドラ番号と割込み番号の割当て，両者の対応
	・割込み優先度の段階数（TMIN_INTPRIの値）
	・dis_intとena_intのサポートの有無，その制限事項
	・CFG_INTの制限事項と拡張（ターゲット定義で使用できる割込み属性）
	・TOPPERS標準割込み処理モデルからのその他の逸脱

(3-3) カーネル管理外の割込みに関する規定
	・TMIN_INTPRIは固定か設定できるか，その設定方法
	・NMI以外にカーネル管理外の割込みを設けるか（設けられるようにするか）
	・カーネル管理外の割込みの設定方法
	・カーネル管理外の割込みに対してDEF_INH，CFG_INTをサポートするか
	・カーネル管理外の割込みハンドラが実行開始される時のシステム状態と
	　コンテキスト
	・割込みハンドラの終了時に行われる処理
	・カーネル管理外の割込みハンドラの記述方法
	・カーネル内の割込み出入口処理で起こる可能性のあるCPU例外

(3-4) CPU例外処理に関する規定
	・CPU例外ハンドラ番号の割当て
	・割込み優先度マスクをTMIN_INTPRIと同じかそれよりも高い値に設定して
	　いる状態で発生したCPU例外を，カーネル管理外のCPU例外と扱うか
	・カーネル内のCPU例外出入口処理で起こる可能性のあるCPU例外

(3-5) 性能評価用システム時刻の参照に関する規定
	・get_utmのサポートの有無，その制限事項

(3-6) その他
	・その他の制限事項
	・その他の拡張機能

(4) カーネルの起動／終了処理に関する情報
	・用意しているスタートアップモジュールの処理内容
	・スタートアップモジュールからhardware_init_hookを呼び出している場
	　合には，hardware_init_hookをアプリケーションで用意する場合の作成
	　方法や制限事項など
	・カーネルを終了した後の振舞い

(5) メモリマップ
	・デフォルトのメモリマップ，その変更方法

(6) タイマドライバ関連の情報
	・タイムティックの周期，その変更方法
	・使用するリソース（タイマ）
	・タイマ割込みの割込み優先度の変更方法
	・オーバランタイマ割込みの割込み優先度の変更方法

(7) シリアルインタフェースドライバの情報
	・使用するリソース（SIOコントローラ）
	・通信パラメータ（ボーレート，ビット数，パリティの有無，ストップビット）

(8) システム構築手順

(9) ターゲットシステム固有の注意事項
	・タスクコンテキストに含まれるレジスタ，含まれないレジスタ

(10) 類似のターゲットにポーティングする開発者向けの参考情報

(11) ディレクトリ構成・ファイル構成

(12) バージョン履歴

また，必要に応じて，ターゲット依存部の設計メモを，target_design.txtに用
意する．プロセッサ・チップ・開発環境依存部に関する設計メモを切り分けて
もよいし，ファイルが大きくなる場合には複数のファイルに分割してもよいが，
その場合には，target_design.txt中にそれらのファイル名を記述すること．

9.2. パッケージ記述ファイル

リリースパッケージ（個別パッケージおよび簡易パッケージ）を作成するため
に，パッケージに含めるファイルを記述したパッケージ記述ファイルを用意す
る．パッケージ記述ファイルの名称は，個別パッケージ用をMANIFEST，簡易パッ
ケージ用をE_PACKAGEとする．

例えば，arch/arm_gccディレクトリに置かれたMANIFESTファイルを用いて個別
パッケージを作成する場合には，次のコマンドを実行する．

	% utils/makerelease arch/arm_gcc/MANIFEST

このコマンドにより，RELEASE/ssp_arch_arm_gcc-<バージョン番号>.tar.gzが
作成される．また，target/at91skyeye_gccディレクトリに置かれたE_PACKAGE
ファイルを用いて簡易パッケージを作成する場合には，次のコマンドを実行す
る．

	% utils/makerelease target/cq_starm_gcc/E_PACKAGE

このコマンドにより，RELEASE/ssp_cq_starm_gcc_gcc-<バージョン番号>.tar.gz
が作成される（RELEASEディレクトリがない場合には，ディレクトリが作られ
る）．

なお，makereleaseユーティリティは，SSPカーネルのソースファイルが置かれ
たディレクトリが，sspという名称であることを仮定している（異なる名称の場
合でもパッケージは作成できるが，パッケージを展開した時に展開されるディ
レクトリがsspでなくなる）．また，標準のtarコマンドがGNU tarであること
（正確には，zオプションに対応していること）を想定している．

パッケージ記述ファイルには，パッケージに含めるファイル名を，パッケージ
記述ファイルが置かれたディレクトリからの相対パス名で，1行に1つずつ記述
する．また，必要に応じて，以下のディレクティブを含める．

(a) E_PACKAGE <簡易パッケージ名>

簡易パッケージ名を指定する．簡易パッケージ記述ファイル（E_PACKAGE）の先
頭に記述する．簡易パッケージ名は，ssp_<ターゲット略称>とする．例えば，
ターゲット略称がcq_starm_gccの場合には，ssp_cq_starm_gccとなる．個
別パッケージと区別するために，簡易パッケージのファイル名には"target"を
含めない．

(b) PACKAGE <個別パッケージ名>

個別パッケージ名を指定する．個別パッケージ記述ファイル（MANIFEST）の先
頭に記述する．また，そこからインクルードされる各ファイルの先頭にも記述
し，それをインクルードしている個別パッケージ名を指定する．ターゲット依
存部の個別パッケージ名は，個別パッケージ記述ファイルが置かれたディレク
トリの相対パス中の"/"を"_"に置き換えた文字列を，"ssp_"の後につなげたも
のとする．例えば，個別パッケージ記述ファイルがarch/arm_gcc/MANIFESTの場
合には，ssp_arch_arm_gccとなる．

(c) VERSION <バージョン番号>

パッケージのバージョン番号を指定する．簡易パッケージ記述ファイルおよび
個別パッケージ記述ファイルの中に記述する．簡易パッケージにおいて，バー
ジョン番号をパッケージ化した日付とする場合には，パッケージ番号の代わり
に%dateと記述する．

バージョン番号の付与方法については，「TOPPERS/SSPカーネル ユーザーズマ
ニュアル」の「2.2 簡易パッケージ」および「2.3 個別パッケージ」の節を参
照すること．

(d) INCLUDE <ファイル名>

別のパッケージ記述ファイルをインクルードする．簡易パッケージ記述ファイ
ルからは，個別パッケージ記述ファイルのみをインクルードするのを原則とす
る．個別パッケージ記述ファイルからインクルードされるファイル中で指定さ
れる個別パッケージ名は，すべて一致していなければならない．


１０．リファレンス

10.1. ターゲット依存部のファイル一覧

標準的なターゲット依存部のファイル構成は次の通りである．

Makefile.target		Makefileのターゲット依存部（２章）．

target_stddef.h		TOPPERS共通定義（t_stddef.h）のターゲット依存部（３
					章）．アプリケーションとカーネルの両方からインクルー
					ドされる．
target_sil.h		システムインタフェースレイヤ（sil.h）のターゲット依
					存部（４章）．アプリケーションとカーネルの両方から
					インクルードされる．
target_kernel.h		カーネルAPI（kernel.h）のターゲット依存部（５章）．
					アプリケーションとカーネルの両方からインクルードさ
					れる．

target_config.h		カーネル実装のターゲット依存部のヘッダファイル（６
					章）．カーネルのみからインクルードされる．
target_config.c		カーネル実装のターゲット依存部のC言語で記述される
					部分（６章，オプション）．
target_support.S	カーネル実装のターゲット依存部のアセンブリ言語で記
					述される部分（６章，オプション）．
target_rename.def	カーネル実装のターゲット依存部のためのリネーム記述
					（6.12節）．
target_rename.h		target_rename.defから生成されるファイル（6.12節）．
target_unrename.h	target_rename.defから生成されるファイル（6.12節）．
target_timer.cfg	タイマドライバのシステムコンフィギュレーションファ
					イル（6.13節）．
target_timer.h		タイマドライバのヘッダファイル（6.13節）．カーネル
					のみからインクルードされる．
target_timer.c		タイマドライバの実装ファイル（6.13節，オプション）．
システム略称.h		ターゲットのハードウェア資源（割込みハンドラ番号や
					CPU例外ハンドラ番号，デバイスレジスタの番地など）の
					定義を含むヘッダファイル．アプリケーションとカーネ
					ルの両方からインクルードされる（６章，オプション）．

target_def.csv		コンフィギュレータの値取得シンボルテーブルのターゲッ
					ト依存部（７章，オプション）．
target.tf			コンフィギュレータのパス2のテンプレートファイルの
					ターゲット依存部（7.2節）．
target_check.tf		コンフィギュレータのパス3のテンプレートファイル（7.3
					節）．
target_cfg1_out.h	cfg1_out.cのリンクに必要なスタブの定義ファイル（7.4
					節）．

target_syssvc.h		システムサービスのターゲット依存定義（8.0節）．
target_serial.cfg	シリアルドライバのシステムコンフィギュレーションファ
					イル（8.3節）．
target_serial.h		シリアルドライバのヘッダファイル（8.3節）．シリアル
					ドライバのみからインクルードされる．
target_serial.c		シリアルドライバの実装ファイル（8.3節，オプション）．
target_test.h		テストプログラムのターゲット依存定義（8.4節）．

target_user.txt		ユーザーズマニュアル（9.1節）
target_design.txt	設計メモ（9.1節，オプション）
MANIFEST			個別パッケージに含めるファイルのリスト（9.2節，オプ
					ション）
E_PACKAGE			簡易パッケージに含めるファイルのリスト（9.2節，オプ
					ション）

以上
